# === 00. IMPORTS === #
import requests
import pandas as pd
import numpy as np
import time
import pyttsx3
import joblib
import itertools
import os
import json
import pickle
import ast
import timeit
import sqlite3
import difflib
import csv
import re
import logging
from sklearn.metrics import accuracy_score
from binance.client import Client
from binance.enums import *
from datetime import datetime
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier
from sklearn.model_selection import StratifiedKFold
from datetime import datetime, timedelta
from ta.trend import EMAIndicator, MACD
from ta.momentum import RSIIndicator
from ta.volume import OnBalanceVolumeIndicator
from ta.volatility import BollingerBands
from ta.utils import dropna
from ta.trend import ADXIndicator
from ta.volatility import AverageTrueRange
from ta.volume import VolumeWeightedAveragePrice
from tpot import TPOTClassifier
from imblearn.over_sampling import SMOTE
from dotenv import load_dotenv
from tabulate import tabulate
from database import salvar_operacao
from database import salvar_performance_modelo
from tabulate import tabulate
from imblearn.over_sampling import SMOTE
from decimal import Decimal
from Backtest_IA import exibir_modelos_vigentes
from sklearn.metrics import accuracy_score
import logging
import warnings
import sys
import io
import locale

# Adicione isso no início do seu código, após os imports
# Silenciar warnings específicos
warnings.filterwarnings("ignore", category=UserWarning, module="sklearn")
warnings.filterwarnings("ignore", category=FutureWarning)
logging.getLogger("sklearn").setLevel(logging.ERROR)
logging.getLogger("joblib").setLevel(logging.ERROR)

from utils import enviar_mensagem_telegram, calcular_indicadores, sanitizar_dataframe, calcular_regime_mercado, enviar_resumo_consolidado, notificar_modelo_carregado, criar_metrica_composta
from utils import executar_pipeline_modelo

# Substitua a configuração atual do sistema de saída por:
# Força UTF-8 no Windows

# Força UTF-8 em todos os sistemas
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

logger = logging.getLogger("trading")
logger.setLevel(logging.INFO)

# ✅ Garante que a pasta logs_execucao existe
os.makedirs("logs_execucao", exist_ok=True)

# Configura handler para arquivo
file_handler = logging.FileHandler("logs_execucao/execucao_IA.txt", encoding='utf-8')
file_handler.setFormatter(logging.Formatter("%(asctime)s - %(message)s"))

# Remove todos os handlers existentes
logger.handlers.clear()

# Aplica apenas o handler de arquivo (não envia nada para o console)
logger.addHandler(file_handler)

warnings.filterwarnings("ignore", category=FutureWarning)
logging.getLogger("sklearn").setLevel(logging.ERROR)
logging.getLogger("joblib").setLevel(logging.ERROR)

# === CONFIGURAÇÕES GERAIS ===
DB_PATH = "trading_ai.db"
HISTORICO_ARQUIVO = "historico_operacoes_OPs.csv"

# Diretório para armazenar os modelos
MODELO_DIR = "modelos"
os.makedirs(MODELO_DIR, exist_ok=True)

# === 01. Configurações Gerais === #
# Binance Configurações
API_KEY = "bliOJOLnQPjswLvWc1AU8Ssl9lsd1VOxO2xz8f8WrF5JEBfYpMmKjVgIyse6ux6i"
SECRET_KEY = "FABfMA13D08nPN4ye7RUO1IcZrgoh9wYWTCAlK0C3OYvizs1iP45SHjR4DgVT2xK"
client = Client(API_KEY, SECRET_KEY)

# Ativos Monitorados
ativos = ["BTCBRL", "ETHBRL", "DOGEBRL", "SOLBRL", "XRPBRL"]
#ativos = ["BTCBRL", "ETHBRL", "DOGEBRL", "SOLBRL", "XRPBRL", "USUALUSDT"]
#periodo_candle = Client.KLINE_INTERVAL_5MINUTE

# Inicializa o engine de voz
engine = pyttsx3.init()

# Variáveis globais para armazenar os saldos e posições
saldos_disponiveis = {}
posicoes_ativas = {}
saldo_inicial = None  # Variável para armazenar o saldo inicial
precos_compra = {}    # Dicionário para armazenar o preço médio de compra dos ativos
dados_sinais = []     # Exemplo de Uso
ultima_compra = {}    # Dicionário para armazenar o timestamp da última compra de cada ativo
ultima_atualizacao_modelo_por_ativo = {}  # Dicionário para acompanhar carregamento de modelos

# Histórico de saldos por período
historico_saldos = {
    "ano": None,
    "mes": None,
    "semana": None,
    "dia": None
}

# Registrar última data atualizada para controle diário
ultima_data_atualizada = {
    "ano": None,
    "mes": None,
    "semana": None,
    "dia": None
}

def atualizar_saldos_periodicos(saldo_atual):
    global historico_saldos, ultima_data_atualizada

    agora = datetime.now()
    ano_atual, mes_atual, semana_atual, dia_atual = agora.year, agora.month, agora.isocalendar()[1], agora.day

    if historico_saldos["ano"] is None or ultima_data_atualizada["ano"] != ano_atual:
        historico_saldos["ano"] = saldo_atual
        ultima_data_atualizada["ano"] = ano_atual

    if historico_saldos["mes"] is None or ultima_data_atualizada["mes"] != mes_atual:
        historico_saldos["mes"] = saldo_atual
        ultima_data_atualizada["mes"] = mes_atual

    if historico_saldos["semana"] is None or ultima_data_atualizada["semana"] != semana_atual:
        historico_saldos["semana"] = saldo_atual
        ultima_data_atualizada["semana"] = semana_atual

    if historico_saldos["dia"] is None or ultima_data_atualizada["dia"] != dia_atual:
        historico_saldos["dia"] = saldo_atual
        ultima_data_atualizada["dia"] = dia_atual

# ✅ Recuperar entradas salvas em disco
for ativo in ativos:
    caminho_entrada = f"modelos/{ativo}_entrada.json"
    if os.path.exists(caminho_entrada):
        try:
            with open(caminho_entrada, "r") as f:
                dados = json.load(f)
                preco_entrada = dados.get("preco_compra", 0)
                if preco_entrada > 0:
                    precos_compra[ativo] = preco_entrada
        except Exception as e:
            print(f"[ERRO] Falha ao carregar entrada de {ativo}: {e}")


# == 02. Banco de Dados e Inicializações === #
def atualizar_modelo_se_melhor(modelo_novo, ativo, score_novo, forcar=False):
    """
    Substitui o modelo salvo apenas se o novo modelo for melhor.
    """
    caminho_modelo = f"modelos/{ativo}_modelo.pkl"
    caminho_meta = f"modelos/{ativo}_meta.json"

    if not os.path.exists(MODELO_DIR):
        os.makedirs(MODELO_DIR)

    meta_atual = {}
    if os.path.exists(caminho_meta):
        with open(caminho_meta, "r") as f:
            meta_atual = json.load(f)

    score_antigo = meta_atual.get("score", 0)
    if forcar or (score_novo > score_antigo):
        joblib.dump(modelo_novo, caminho_modelo)
        meta_atual["score"] = score_novo
        meta_atual["timestamp"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        with open(caminho_meta, "w") as f:
            json.dump(meta_atual, f, indent=2)
        return True

    return False

def configurar_logging():
    """
    Configura sistema de logging padronizado para facilitar diagnóstico de erros.
    Cria logs separados para diferentes componentes do sistema.
    
    Retorna:
        dict: Dicionário com loggers configurados para diferentes partes do sistema
    """
    import logging
    import os
    import sys
    
    # Criar diretório para logs se não existir
    if not os.path.exists('logs'):
        os.makedirs('logs')
    
    # Data atual para nomes de arquivo
    data_atual = datetime.now().strftime('%Y-%m-%d')
    
    # Configurar formato comum para todas as mensagens
    formato = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # Criar diferentes loggers para componentes do sistema
    loggers = {}
    
    # 1. Logger para trading (operações de compra e venda)
    trading_logger = logging.getLogger('trading')
    trading_logger.setLevel(logging.INFO)
    
    # Impede que mensagens do logger 'trading' vazem para o console
    logger.propagate = False

    
    # Handler para arquivo
    trading_handler = logging.FileHandler(f'logs/trading_{data_atual}.log')
    trading_handler.setFormatter(formato)
    trading_logger.addHandler(trading_handler)
    
    # ❌ NÃO adiciona console handler
    # Apenas logs em arquivo
    # console_handler = logging.StreamHandler()
    # console_handler.setFormatter(formato)
    # trading_logger.addHandler(console_handler)

    
    loggers['trading'] = trading_logger
    
    # 2. Logger para backtesting
    backtest_logger = logging.getLogger('backtest')
    backtest_logger.setLevel(logging.INFO)
    
    backtest_handler = logging.FileHandler(f'logs/backtest_{data_atual}.log')
    backtest_handler.setFormatter(formato)
    backtest_logger.addHandler(backtest_handler)
    #backtest_logger.addHandler(console_handler)  # Reutilizar console handler
    
    loggers['backtest'] = backtest_logger
    
    # 3. Logger para erros (nível mais detalhado)
    error_logger = logging.getLogger('error')
    error_logger.setLevel(logging.DEBUG)  # Debug para capturar tudo
    
    error_handler = logging.FileHandler(f'logs/error_{data_atual}.log')
    error_handler.setFormatter(formato)
    error_logger.addHandler(error_handler)
    
    loggers['error'] = error_logger
    
    # 4. Logger para modelo (treinamento e previsões)
    model_logger = logging.getLogger('model')
    model_logger.setLevel(logging.INFO)
    
    model_handler = logging.FileHandler(f'logs/model_{data_atual}.log')
    model_handler.setFormatter(formato)
    model_logger.addHandler(model_handler)
    
    loggers['model'] = model_logger
    
    # Configurar exceções não capturadas para irem para o log de erros
    def handler_excecao(tipo, valor, traceback):
        error_logger.critical("Exceção não capturada:", exc_info=(tipo, valor, traceback))
        # Mostrar também no stderr padrão
        sys.__excepthook__(tipo, valor, traceback)
    
    # Substituir o handler de exceções padrão
    sys.excepthook = handler_excecao
    
    # Função auxiliar para facilitar o logging de erros em blocos try-except
    def log_exception(e, mensagem="Erro não especificado", logger_name='error'):
        import traceback
        if logger_name in loggers:
            loggers[logger_name].error(f"{mensagem}: {str(e)}")
            loggers[logger_name].debug(traceback.format_exc())
        else:
            error_logger.error(f"{mensagem}: {str(e)}")
            error_logger.debug(traceback.format_exc())
    
    # Adicionar a função ao dicionário de loggers
    loggers['log_exception'] = log_exception
    
    return loggers    
                    
def conectar_bd():
    return sqlite3.connect(DB_PATH)

def inicializar_bd():
    conn = conectar_bd()
    cursor = conn.cursor()

    # Tabela de operações (compras e vendas)
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS operacoes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        data TEXT,
        ativo TEXT,
        operacao TEXT,
        quantidade REAL,
        preco REAL,
        valor_total REAL,
        lucro_percentual REAL
    )
    """)

    # Tabela de performance dos modelos
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS performance_modelos (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        data TEXT,
        ativo TEXT,
        taxa_acerto REAL,
        intervalo TEXT,
        indicadores TEXT
    )
    """)

    conn.commit()
    conn.close()

def inicializar_historico():
    """
    Inicializa o arquivo de histórico de operações se ele não existir.
    Cria um arquivo CSV com cabeçalhos apropriados.
    """
    HISTORICO_ARQUIVO = "historico_operacoes.csv"  # Certifique-se de usar o mesmo nome definido em outras partes do código
    
    import os
    import csv
    if not os.path.exists(HISTORICO_ARQUIVO):
        with open(HISTORICO_ARQUIVO, mode='w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([
                "Data", "Ativo", "Operação", "Quantidade", "Preço",
                "Valor Total", "Lucro (%)", "Status"
            ])
        print(f"✅ Arquivo de histórico criado: {HISTORICO_ARQUIVO}")
    else:
        print(f"✅ Arquivo de histórico existente: {HISTORICO_ARQUIVO}")

def salvar_operacao(ativo, operacao, quantidade, preco, lucro_percentual=None):
    conn = conectar_bd()
    cursor = conn.cursor()

    valor_total = quantidade * preco
    data = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    cursor.execute("""
    INSERT INTO operacoes (data, ativo, operacao, quantidade, preco, valor_total, lucro_percentual)
    VALUES (?, ?, ?, ?, ?, ?, ?)
    """, (data, ativo, operacao, quantidade, preco, valor_total, lucro_percentual))

    conn.commit()
    conn.close()

def salvar_performance_modelo(ativo, taxa_acerto, intervalo, indicadores):
    """
    Registra a performance do modelo no banco de dados.
    """
    conn = conectar_bd()
    cursor = conn.cursor()

    data = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    indicadores_str = ", ".join(indicadores)

    cursor.execute("""
    INSERT INTO performance_modelos (data, ativo, taxa_acerto, intervalo, indicadores)
    VALUES (?, ?, ?, ?, ?)
    """, (data, ativo, taxa_acerto, intervalo, indicadores_str))

    conn.commit()
    conn.close()

    print(f"📊 Performance registrada: {ativo} | Taxa de Acerto: {taxa_acerto:.2f}% | Intervalo: {intervalo} | Indicadores: {indicadores}")


# === 03. Funções de voz e notificação === #
def falar(frase):
    engine.say(frase)
    engine.runAndWait()

def falar_eventos(evento, ativo=None, lucro=None):
    """
    Emite falas para eventos importantes como compra, venda, backtest e otimizações.
    """
    if evento == "compra":
        falar(f"Compra realizada para {ativo} com sucesso.")
    elif evento == "venda":
        falar(f"Venda realizada para {ativo}. Lucro de {lucro:.2f} por cento.")
    elif evento == "backtest":
        falar("Backtest concluído. Modelos foram atualizados.")
    elif evento == "otimizacao":
        falar("Otimização realizada com sucesso. Estratégias ajustadas.")


# === 04. Funções de saldo e posições === #
def ajustar_quantidade_para_lot_size(quantidade, symbol):
    """
    Ajusta a quantidade para o lote mínimo permitido pela Binance.
    Retorna: (quantidade_ajustada, min_qty, min_notional).
    """
    info = client.get_symbol_info(symbol)

    if not info:
        print(f"⚠️ Erro: Não foi possível obter as regras de lote mínimo para {symbol}.")
        return 0, 0, 0

    min_qty = 0
    step_size = 0
    min_notional = 0

    for f in info["filters"]:
        if f["filterType"] == "LOT_SIZE":
            min_qty = float(f["minQty"])
            step_size = float(f["stepSize"])
        elif f["filterType"] == "MIN_NOTIONAL":
            min_notional = float(f["minNotional"])
        elif f["filterType"] == "NOTIONAL":
            min_notional = float(f.get("minNotional", 0))

    # ✅ Fallback manual caso min_notional não seja encontrado
    if min_notional == 0:
        print(f"⚠️ Nenhum min_notional encontrado para {symbol}. Usando fallback de R$10.")
        min_notional = 10

    # Garantir que quantidade é um número válido
    try:
        quantidade = float(quantidade)
    except (ValueError, TypeError):
        print(f"⚠️ Quantidade inválida: {quantidade}. Usando 0.")
        quantidade = 0

    # Ajustar a precisão com base no step_size
    if step_size > 0:
        # Determinar o número de casas decimais com base no step_size
        precision = len(str(step_size).split('.')[-1])
        # Arredondamento para o múltiplo de step_size mais próximo
        quantidade_ajustada = round(quantidade - (quantidade % step_size), precision)
        # Garantir que é pelo menos o mínimo
        quantidade_ajustada = max(quantidade_ajustada, min_qty)
        # Formatar com a precisão correta como string
        quantidade_ajustada = "{:.{}f}".format(quantidade_ajustada, precision)
        # Remover zeros à direita e pontos desnecessários
        quantidade_ajustada = quantidade_ajustada.rstrip('0').rstrip('.') if '.' in quantidade_ajustada else quantidade_ajustada
    else:
        quantidade_ajustada = str(quantidade)

    # Converter de volta para float para comparações
    quantidade_float = float(quantidade_ajustada)
    
    # Verificar se a quantidade atende aos requisitos mínimos
    if quantidade_float < min_qty:
        print(f"⚠️ Quantidade ajustada ({quantidade_float}) abaixo do lote mínimo ({min_qty}).")
        return 0, min_qty, min_notional
    
    # Retornar a quantidade como string formatada corretamente para a API
    return quantidade_ajustada, min_qty, min_notional

def listar_saldos(modo_silencioso=False):
    """
    Obtém os saldos disponíveis da Binance e determina a posição dos ativos.
    
    Parâmetros:
    - modo_silencioso: Se True, não imprime detalhes dos saldos no console
    """
    global saldos_disponiveis, posicoes_ativas

    try:
        conta = client.get_account()
        novos_saldos = {}
        novas_posicoes = {}

        if not modo_silencioso:
            print("\n📌 [DEBUG] Obtendo saldos disponíveis...")

        # Obtenção dos saldos
        for item in conta["balances"]:
            ativo = item["asset"]
            saldo = float(item["free"])
            if saldo > 0:
                novos_saldos[ativo] = saldo

        saldos_disponiveis = novos_saldos.copy()

        # Impressão detalhada apenas se não estiver em modo silencioso
        if not modo_silencioso:
            print("\n{:<6} {:>12} {:>15} {:>15}".format("Ativo", "Qty Ativo", "Lote Mínimo", "Posição"))
            print("=" * 50)

        # Processamento dos ativos
        for ativo in ativos:
            ativo_base = ativo.replace("BRL", "")
            saldo_ativo = float(saldos_disponiveis.get(ativo_base, 0))
            _, min_qty, min_notional = ajustar_quantidade_para_lot_size(saldo_ativo, ativo)

            try:
                preco_atual = float(client.get_symbol_ticker(symbol=ativo)["price"])
            except:
                preco_atual = 0  

            tem_posicao = saldo_ativo >= min_qty and (saldo_ativo * preco_atual) >= min_notional
            novas_posicoes[ativo] = tem_posicao

            # Impressão detalhada apenas se não estiver em modo silencioso
            if not modo_silencioso:
                status_posicao = "✅ SIM" if tem_posicao else "🛑 NÃO"
                print("{:<6} {:>12.6f} {:>15.6f} {:>15}".format(
                    ativo_base, saldo_ativo, min_qty, status_posicao
                ))

        # Cálculo de saldo e investimento
        saldo_brl = float(saldos_disponiveis.get("BRL", 0))
        ativos_sem_posicao = [a for a in ativos if not novas_posicoes[a]]
        investimento_por_ativo = saldo_brl / len(ativos_sem_posicao) if ativos_sem_posicao else 0  

        saldos_disponiveis["investimento_por_ativo"] = investimento_por_ativo
        posicoes_ativas = novas_posicoes

        # Impressão resumida apenas se não estiver em modo silencioso
        if not modo_silencioso:
            print("\n📌 Saldo BRL: R${:.2f} | Investimento por ativo: R${:.2f}".format(
                saldo_brl, investimento_por_ativo
            ))

    except Exception as e:
        print(f"❌ Erro ao listar saldos: {e}")

def obter_saldo_inicial_fixo(periodo, chave, saldo_atual):
    """
    Recupera ou grava o saldo inicial fixo por período (dia, semana, mês, ano).
    """
    arquivo_saldos = "saldos_iniciais.json"
    saldos = {}

    # Carrega arquivo, se existir
    if os.path.exists(arquivo_saldos):
        with open(arquivo_saldos, "r") as f:
            try:
                saldos = json.load(f)
            except:
                saldos = {}

    # Cria estrutura se necessário
    if periodo not in saldos:
        saldos[periodo] = {}

    # Se já existe, retorna
    if chave in saldos[periodo]:
        return saldos[periodo][chave]

    # Caso contrário, define e salva
    saldos[periodo][chave] = saldo_atual
    with open(arquivo_saldos, "w") as f:
        json.dump(saldos, f, indent=2)

    return saldo_atual
        
def retroalimentar_modelo(ativo):
    """
    Extrai operações históricas e retroalimenta o modelo com base nas variações de preço.
    """
    modelo_path = f"modelos/{ativo}_modelo.pkl"
    if not os.path.exists(modelo_path):
        print(f"❌ Modelo não encontrado para {ativo}")
        return False

    # 1. Coleta de operações
    try:
        conn = conectar_bd()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT preco, operacao, data FROM operacoes
            WHERE ativo = ? ORDER BY data ASC
        """, (ativo,))
        dados = cursor.fetchall()
        conn.close()

        if len(dados) < 10:
            print(f"⚠️ Poucos dados para retroalimentar modelo de {ativo}")
            return False
    except Exception as e:
        print(f"❌ Erro ao acessar banco: {e}")
        return False

    # 2. Construção de dados supervisionados
    X_novos = []
    y_novos = []

    for i in range(1, len(dados)):
        preco_ant, _, data_ant = dados[i - 1]
        preco_atual, oper, data_atual = dados[i]

        variacao_pct = ((preco_atual - preco_ant) / preco_ant) * 100 if preco_ant > 0 else 0
        X_novos.append([variacao_pct])  # Feature: variação anterior
        y_novos.append(1 if preco_atual > preco_ant else 0)

    # 3. Carregamento e retrofit
    try:
        modelo = joblib.load(modelo_path)
        if hasattr(modelo, "partial_fit"):

            # Recuperar features esperadas
            features_modelo = getattr(modelo, 'feature_names_in_', None)

            # Se o modelo espera múltiplas features, não aplicar retrofit com apenas uma
            if features_modelo is not None and len(features_modelo) > 1:
                print(f"⚠️ Modelo espera {len(features_modelo)} features. Retrofit cancelado: apenas 1 fornecida.")
                return False
            
            modelo.partial_fit(X_novos, y_novos, classes=[0, 1])
            logger.info(f"✅ [RETROFIT] Modelo {ativo} atualizado com {len(X_novos)} exemplos.")
        else:
            modelo = RandomForestClassifier(n_estimators=100)
            modelo.fit(X_novos, y_novos)

        joblib.dump(modelo, modelo_path)
        print(f"✅ Modelo retroalimentado e salvo ({len(X_novos)} exemplos)")
        return True
    except Exception as e:
        print(f"⚠️ Erro no retrofit de modelo {ativo}: {e}")
        return False

def registrar_distribuicao_features(ativo, df, caminho="distribuicoes"):
    """
    Salva a distribuição estatística das features mais recentes para comparar deriva do modelo.
    """
    os.makedirs(caminho, exist_ok=True)
    stats_path = os.path.join(caminho, f"{ativo}_distribuicao.csv")

    try:
        estatisticas = df.describe().T[["mean", "std", "min", "max"]]
        estatisticas["data"] = datetime.now().strftime("%Y-%m-%d")
        estatisticas.to_csv(stats_path, mode='a', header=not os.path.exists(stats_path))
    except Exception as e:
        print(f"⚠️ Erro ao registrar distribuição de features para {ativo}: {e}")




# === 05. Funções de busca de dados e carga de modelos === #
def buscar_dados_binance(ativos, tentativas_max=3, modo_silencioso=False):
    """
    Obtém os dados de mercado da Binance para os ativos fornecidos.
    
    Parâmetros:
    - ativos: Lista de ativos para buscar dados
    - tentativas_max: Número máximo de tentativas em caso de falha
    - modo_silencioso: Se True, reduz as mensagens de log
    
    Retorna:
    - Tupla com (dados_mercado, modelos_info) onde:
        - dados_mercado: Dicionário com os dados de cada ativo
        - modelos_info: Dicionário com informações dos modelos carregados
    """
    if not modo_silencioso:
        print(f"\n🔹 [COLETANDO DADOS DE MERCADO] 🔹 {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        
    dados_mercado = {}
    falhas = []
    
    # Dicionário para armazenar informações dos modelos carregados
    modelos_info = {}

    for ativo in ativos:
        tentativas = tentativas_max
        df = None

        while tentativas > 0:
            try:
                klines = client.get_klines(
                    symbol=ativo,
                    interval=Client.KLINE_INTERVAL_5MINUTE,
                    limit=500
                )

                if not klines:
                    raise ValueError(f"⚠️ Nenhum dado retornado para {ativo}")

                df = pd.DataFrame(klines, columns=[
                    "timestamp", "open", "high", "low", "close", "volume",
                    "close_time", "quote_asset_volume", "number_of_trades",
                    "taker_buy_base", "taker_buy_quote", "ignore"
                ])

                df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
                df[["open", "high", "low", "close", "volume"]] = df[["open", "high", "low", "close", "volume"]].astype(float)

                # Mantém apenas colunas essenciais
                df = df[["timestamp", "open", "high", "low", "close", "volume"]]

                # Se as colunas essenciais existem e o DataFrame não está vazio, interrompe o loop
                if not df.empty and all(col in df.columns for col in ["open", "high", "low", "close", "volume"]):
                    break

            except Exception as e:
                if not modo_silencioso:
                    print(f"⚠️ [ERRO] Falha ao obter dados para {ativo} ({tentativas} tentativas restantes): {e}")
                df = None
                tentativas -= 1
                time.sleep(2)  # Aguarda 2 segundos antes de tentar novamente

        if df is not None and not df.empty:
            if not modo_silencioso:
                print(f"✅ [DEBUG] Dados obtidos para {ativo}")
            dados_mercado[ativo] = df
            
            # Carregar informações do modelo sem imprimir duplicações
            try:
                _, _, _, _, intervalo, _ = carregar_modelo(ativo)
                modelos_info[ativo] = intervalo
                if not modo_silencioso:
                    print(f"✅ Modelo carregado para {ativo}: {intervalo}")
            except Exception as e:
                if not modo_silencioso:
                    print(f"⚠️ Erro ao carregar modelo para {ativo}: {e}")
        else:
            falhas.append(ativo)

    if falhas and not modo_silencioso:
        print(f"⚠️ Falha na busca de dados para: {', '.join(falhas)}")

    return dados_mercado, modelos_info

def obter_intervalo_modelo(ativo):
    """
    Função simplificada que apenas retorna o intervalo do modelo,
    sem carregar o modelo completo para evitar prints desnecessários.
    """
    caminho_meta = f"modelos/{ativo}_meta.json"

    intervalo = "5m"  # valor padrão

    if os.path.exists(caminho_meta):
        try:
            with open(caminho_meta, "r") as f:
                meta = json.load(f)
                intervalo = meta.get("intervalo", "5m")
        except Exception:
            pass
    
    return intervalo

def obter_saldo_inicial(lista_saldo):
    """
    Retorna o saldo inicial do dia baseado na lista de saldo da corretora.
    O saldo inicial é armazenado apenas na primeira execução.
    """
    global saldo_inicial

    if saldo_inicial is None:
        saldo_inicial = lista_saldo.get("BRL", 0)  # Obtém o saldo em BRL na primeira execução

    return saldo_inicial

def obter_saldo_atual(lista_saldo):
    """
    Retorna o saldo atual disponível em BRL, baseado na lista de saldo da corretora.
    Se não houver saldo registrado, retorna 0.
    """
    return lista_saldo.get("BRL", 0)  # Obtém o saldo em BRL ou retorna 0 se não existir

def carregar_modelo(ativo):
    """
    Carrega o modelo salvo, junto com suas informações principais.
    Lida com arquivos potencialmente corrompidos.

    Retorna:
      (modelo, scaler, meta_info, indicadores, intervalo)
    """
    import os
    import joblib
    import json

    caminho_modelo = f"modelos/{ativo}_modelo.pkl"
    caminho_meta = f"modelos/{ativo}_meta.json"
    caminho_scaler = f"modelos/{ativo}_scaler.pkl"

    modelo, scaler, meta_info, indicadores = None, None, {}, []
    intervalo = "5m"

    if os.path.exists(caminho_modelo) and os.path.exists(caminho_meta):
        try:
            # Verificar tamanho do arquivo - arquivos muito pequenos provavelmente estão corrompidos
            tamanho_arquivo = os.path.getsize(caminho_modelo)
            if tamanho_arquivo < 100:  # Tamanho mínimo razoável para um modelo serializado
                print(f"⚠️ Arquivo de modelo para {ativo} parece estar corrompido (tamanho: {tamanho_arquivo} bytes)")
                
                # Renomear arquivo corrompido
                try:
                    backup_path = f"{caminho_modelo}.corrupted"
                    os.rename(caminho_modelo, backup_path)
                    print(f"🔄 Arquivo corrompido movido para {backup_path}")
                except Exception as rename_err:
                    print(f"⚠️ Não foi possível renomear arquivo corrompido: {rename_err}")
                
                return None, None, {}, [], intervalo
            
            modelo = joblib.load(caminho_modelo)

            if hasattr(modelo, 'feature_names_in_'):
                pass  # já definido
            elif "indicadores" in meta_info:
                modelo.feature_names_in_ = np.array(meta_info["indicadores"])
            else:
                print(f"⚠️ Modelo {ativo} sem feature_names_in_ nem indicadores salvos.")
            
            # === Validação do Scaler ===
            # Carregar meta antes de validar scaler
            with open(caminho_meta, "r", encoding='utf-8') as f:
                meta_info = json.load(f)
            indicadores = meta_info.get("indicadores", [])
            intervalo = meta_info.get("intervalo", "5m")
            regime = meta_info.get("regime", "DESCONHECIDO")

            # === Validação do Scaler ===
            if os.path.exists(caminho_scaler):
                try:
                    scaler = joblib.load(caminho_scaler)
                    if hasattr(scaler, "n_features_in_") and len(indicadores) != scaler.n_features_in_:
                        print(f"⚠️ Scaler incompatível: esperado {scaler.n_features_in_}, atual {len(indicadores)}")
                        scaler = None
                    elif hasattr(scaler, "transform"):
                        teste = np.array([[0.1]*len(indicadores)]).astype(float)
                        _ = scaler.transform(teste)
                    else:
                        raise ValueError("Scaler inválido ou não possui método transform.")

                except Exception as e:
                    print(f"⚠️ Erro de integridade no scaler de {ativo}: {e}")
                    scaler = None
            else:
                print(f"⚠️ Scaler ausente para {ativo}")
                scaler = None
            
            with open(caminho_meta, "r", encoding='utf-8') as f:
                meta_info = json.load(f)
            
            indicadores = meta_info.get("indicadores", [])
            intervalo = meta_info.get("intervalo", "5m")
            regime = meta_info.get("regime", "DESCONHECIDO")

            # Garante que regime nunca seja vazio
            if not regime or regime.strip() == "":
                regime = "DESCONHECIDO"
            
            # Exemplo de notificação para telegram/log se for a 1ª vez em 4h
            global ultima_atualizacao_modelo_por_ativo
            timestamp_atual = datetime.now()
            if 'ultima_atualizacao_modelo_por_ativo' not in globals():
                ultima_atualizacao_modelo_por_ativo = {}
            
            if (ativo not in ultima_atualizacao_modelo_por_ativo or 
                (timestamp_atual - ultima_atualizacao_modelo_por_ativo[ativo]).total_seconds() > 14400):
                # notificar_modelo_carregado(ativo, intervalo, meta_info.get("score", 0.0), indicadores)
                ultima_atualizacao_modelo_por_ativo[ativo] = timestamp_atual
            
            return modelo, scaler, meta_info, indicadores, intervalo, regime

        except Exception as e:
            print(f"⚠️ Erro ao carregar modelo para {ativo}: {e}")
            
            # Se o arquivo existe mas não pôde ser carregado, ele pode estar corrompido
            # Vamos renomeá-lo para forçar um novo treinamento
            try:
                # Renomear para backup em vez de excluir
                backup_path = f"{caminho_modelo}.corrupted"
                os.rename(caminho_modelo, backup_path)
                print(f"🔄 Arquivo corrompido movido para {backup_path}")
            except Exception as rename_err:
                print(f"⚠️ Não foi possível renomear arquivo corrompido: {rename_err}")
                
            return None, None, {}, [], intervalo
    else:
        # print(f"⚠️ Nenhum modelo encontrado para {ativo}.")
        return None, None, {}, [], intervalo

def registrar_operacao(ativo, operacao, quantidade, preco, preco_compra=None, razoes=None):
    """
    Registra a operação de compra ou venda no histórico, no banco de dados e envia mensagem ao Telegram.
    Inclui explicações detalhadas sobre as razões da operação.
    """
    global precos_compra

    valor_total = quantidade * preco
    lucro_percentual = 0.0
    lucro_real = 0.0
    taxa_sucesso = False  # Define se a operação teve sucesso ou não

    # Se for VENDA, calcula lucro/prejuízo
    if operacao == "VENDA" and preco_compra:
        if preco_compra > 0:
            lucro_percentual = ((preco - preco_compra) / preco_compra) * 100
            lucro_real = (preco - preco_compra) * quantidade
            taxa_sucesso = lucro_percentual > 0.2  # Considera sucesso se lucro > 0,2%

    # Indicadores legíveis
    status_texto = "SUCESSO" if taxa_sucesso else "FALHA"
            
    # Gravar no arquivo de histórico CSV
    try:
        with open(HISTORICO_ARQUIVO, mode='a', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"), ativo, operacao, quantidade, preco,
                valor_total, round(lucro_percentual, 2) if isinstance(lucro_percentual, float) else lucro_percentual,
                status_texto,
                "NAO"  # <-- Aprendido: "NAO" por padrão
            ])

    except Exception as e:
        print(f"[X] Erro ao gravar no histórico CSV: {e}")

    # Gravar no banco de dados
    try:
        salvar_operacao(ativo, operacao, quantidade, preco, 
                        float(lucro_percentual) if isinstance(lucro_percentual, float) else None)
    except Exception as e:
        print(f"[X] Erro ao salvar no banco de dados: {e}")

    # Log no terminal
    print(f"[INFO] Operação registrada: {operacao} {ativo} | Qtde: {quantidade} | Preço: R${preco:.2f} | Lucro: {lucro_percentual:.2f}% | Status: {status_texto}")

    # Enviar mensagem ao Telegram com formato padronizado e melhorado
    try:
        _, _, _, _, intervalo, _ = carregar_modelo(ativo)
        
        # Formatar razões para melhor visualização se existirem
        razoes_formatadas = ""
        if razoes:
            # Verifica se já está formatado como tópicos
            if "• " in razoes:
                razoes_formatadas = f"\n{razoes}"
            else:
                # Tenta dividir em linhas se houver separadores comuns
                itens = []
                if ", " in razoes:
                    itens = razoes.split(", ")
                elif " | " in razoes:
                    itens = razoes.split(" | ")
                else:
                    itens = [razoes]  # Mantém como um único item
                
                # Formata como tópicos
                razoes_formatadas = "\n• " + "\n• ".join(itens)
        
        # Formata emojis indicadores de estado
        if operacao == "COMPRA":
            emoji_operacao = "🟢"
            status_emoji = "💵"
        else:  # VENDA
            emoji_operacao = "🔴"
            if lucro_percentual > 0:
                status_emoji = "💰"  # Lucro
            else:
                status_emoji = "📉"  # Prejuízo
        
        if operacao == "COMPRA":
            mensagem = f"""
{emoji_operacao} *COMPRA REALIZADA* {status_emoji}
------------------------------------------
🔹 *Ativo:* {ativo}
🔹 *Quantidade:* {quantidade:.6f}
🔹 *Preço de Compra:* R$ {preco:.2f}
🔹 *Intervalo:* {intervalo}

📊 *RAZÕES DA OPERAÇÃO:* {razoes_formatadas}
"""
        else:  # VENDA
            # Determina emoji de lucro/prejuízo
            if lucro_percentual > 3:
                emoji_lucro = "🤑"  # Lucro excelente
            elif lucro_percentual > 0:
                emoji_lucro = "💰"  # Lucro positivo
            elif lucro_percentual > -3:
                emoji_lucro = "⚠️"  # Pequeno prejuízo
            else:
                emoji_lucro = "📉"  # Prejuízo significativo
            
            preco_compra_formatado = preco_compra if preco_compra and preco_compra > 0 else 0
            mensagem = f"""
{emoji_operacao} *VENDA REALIZADA* {status_emoji}
------------------------------------------
🔹 *Ativo:* {ativo}
🔹 *Quantidade:* {quantidade:.6f}
🔹 *Preço de Venda:* R$ {preco:.2f}
🔹 *Preço de Compra:* R$ {preco_compra_formatado:.2f}
🔹 *Lucro:* {lucro_percentual:.2f}% {emoji_lucro}
🔹 *Lucro Real:* R$ {lucro_real:.2f}
🔹 *Status:* {status_texto}

📊 *RAZÕES DA OPERAÇÃO:* {razoes_formatadas}
"""
        
        # Enviar a mensagem padronizada ao Telegram
        enviar_mensagem_telegram(mensagem)
    except Exception as e:
        print(f"[X] Erro ao enviar notificação ao Telegram: {e}")

    # Atualiza ou remove o preço de compra
    if operacao == "COMPRA":
        precos_compra[ativo] = preco

        # ✅ Salvar entrada em arquivo
        with open(f"modelos/{ativo}_entrada.json", "w") as f:
            json.dump({
                "ativo": ativo,
                "preco_compra": preco,
                "data": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }, f)

    elif operacao == "VENDA":
        precos_compra.pop(ativo, None)

        # ✅ Apagar o arquivo de entrada salvo
        caminho = f"modelos/{ativo}_entrada.json"
        if os.path.exists(caminho):
            os.remove(caminho)
            
        # ✅ Retrofit do modelo após venda
        try:
            resultado_retrofit = retroalimentar_modelo(ativo)
            if resultado_retrofit:
                print(f"🔁 Modelo de {ativo} retroalimentado após venda.")
        except Exception as e:
            print(f"⚠️ Erro ao retroalimentar modelo de {ativo} após venda: {e}")

def retroalimentar_com_csv(ativo):
    """
    Treina o modelo usando operações anteriores marcadas como 'NAO' no campo Aprendido
    """
    import pandas as pd

    if not os.path.exists(HISTORICO_ARQUIVO):
        print(f"📁 Histórico {HISTORICO_ARQUIVO} não encontrado.")
        return

    try:
        # ✅ Validação de colunas antes de processar
        with open(HISTORICO_ARQUIVO, 'r') as f:
            header = f.readline().strip().split(',')
            if len(header) < 8:
                print(f"❌ CSV com estrutura inválida. Esperado >=8 colunas, recebido: {len(header)}")
                return

        # ✅ Leitura robusta com tratamento de linhas corrompidas
        df = pd.read_csv(HISTORICO_ARQUIVO, on_bad_lines='skip', engine='python')

        # Validação das colunas essenciais
        colunas_esperadas = ["Ativo", "Operação", "Quantidade", "Preço", "Lucro (%)", "Aprendido"]
        for col in colunas_esperadas:
            if col not in df.columns:
                print(f"❌ Coluna ausente no CSV: {col}")
                return

        if "Ativo" not in df.columns:
            print("❌ Coluna ausente no CSV: Ativo")
            return

        df_ativo = df[(df["Ativo"] == ativo) & (df["Aprendido"] != "SIM")]


        if df_ativo.empty:
            print(f"ℹ️ Nenhum dado novo para retroalimentar modelo de {ativo}")
            return

        # Define X_novos e y_novos com base na operação
        df_ativo = df_ativo[df_ativo["Operação"].isin(["COMPRA", "VENDA"])]
        df_ativo["target"] = df_ativo["Operação"].apply(lambda x: 1 if x == "COMPRA" else 0)

        # Usar features simplificadas — para testar funcionamento
        regimes = df_ativo.get("Regime", "NEUTRO").fillna("NEUTRO").apply(lambda x: {"TENDÊNCIA": 1, "LATERAL": 0, "NEUTRO": -1}.get(x, -1))
        X_novos = df_ativo[["Preço", "Lucro (%)"]].copy()
        X_novos["Regime"] = regimes
        X_novos = X_novos.fillna(0)
        y_novos = df_ativo["target"]

        sucesso = retroalimentar_modelo(ativo, X_novos, y_novos)

        if sucesso:
            df.loc[df_ativo.index, "Aprendido"] = "SIM"
            df.to_csv(HISTORICO_ARQUIVO, index=False)
            print(f"✅ Aprendizado retroativo aplicado para {ativo}")
    except Exception as e:
        print(f"⚠️ Erro ao retroalimentar {ativo} com CSV: {e}")


# Variável global para armazenar ordens pendentes
global ordens_pendentes
if 'ordens_pendentes' not in globals():
    ordens_pendentes = {}  # Inicializa caso não exista

# Dicionário para registrar a última operação de cada ativo
ultima_operacao_tempo = {}  # Armazena o timestamp da última operação
tempo_minimo_entre_operacoes = {}  # Armazena o tempo mínimo entre operações para cada ativo



# === 06. Funções de logica de trading === #
def executar_ordens(dados_sinais):
    """
    Executa ordens de compra e venda com controle de tempo entre operações e
    inclui as razões nos registros de operação.
    """
    listar_saldos(modo_silencioso=True)
    tempo_atual = datetime.now()
    
    for ativo, posicao, indicadores, sinal, regime, razoes in dados_sinais:
        
        # === Carrega modelo e scaler para o ativo ===
        caminho_modelo = f"modelos/{ativo}_modelo.pkl"
        caminho_scaler = f"modelos/{ativo}_scaler.pkl"

        try:
            modelo = joblib.load(caminho_modelo)
        except Exception as e:
            print(f"❌ Erro ao carregar modelo de {ativo}: {e}")
            continue

        try:
            scaler = joblib.load(caminho_scaler)
        except FileNotFoundError:
            scaler = None
            print(f"⚠️ Scaler ausente para {ativo}")
        
        try:
            # Verificar tempo desde a última operação
            intervalo_modelo = modelos_info.get(ativo, "15m")  # Obtém o intervalo do modelo
            tempo_minimo = tempo_minimo_entre_operacoes.get(ativo, calcular_tempo_espera(intervalo_modelo))
            
            # Se não tiver registro anterior, registre o intervalo mínimo para este ativo
            if ativo not in tempo_minimo_entre_operacoes:
                tempo_minimo_entre_operacoes[ativo] = calcular_tempo_espera(intervalo_modelo)
                print(f"[INFO] Tempo mínimo entre operações para {ativo}: {tempo_minimo_entre_operacoes[ativo]//60} minutos")
            
            # Verifica se já se passou tempo suficiente desde a última operação
            if ativo in ultima_operacao_tempo:
                tempo_passado = (tempo_atual - ultima_operacao_tempo[ativo]).total_seconds()
                if tempo_passado < tempo_minimo:
                    tempo_restante = (tempo_minimo - tempo_passado) // 60
                    print(f"[INFO] Aguardando tempo mínimo para {ativo}. Faltam {tempo_restante} minutos.")
                    continue  # Pula para o próximo ativo
            
            preco_atual = float(client.get_symbol_ticker(symbol=ativo)["price"])
            saldo_brl = saldos_disponiveis.get("BRL", 0)
            ativo_base = ativo.replace("BRL", "")
            quantidade_ativo = saldos_disponiveis.get(ativo_base, 0)

            # Sanitizar strings com emojis para evitar problemas de codificação
            sinal_texto = "COMPRA" if "COMPRA" in sinal else "VENDA" if "VENDA" in sinal else "NEUTRO"

            # 🔍 Extração da confiança a partir da razão textual (se disponível)
            conf_match = re.search(r'Conf(?:iança)?:\s*([\d.]+)%', razoes)
            confianca = float(conf_match.group(1)) if conf_match else 0

            # ⚠️ Pular se confiança for baixa
            if confianca < 55:
                print(f"[IGNORADO] {ativo}: Confiança {confianca:.1f}% insuficiente para ação ({sinal_texto})")
                continue
                
                if sinal_texto == "COMPRA" and not posicoes_ativas.get(ativo, False):
                    investimento = saldos_disponiveis.get("investimento_por_ativo", 0)
                    print(f"[RAZÃO DA COMPRA] {ativo}: {razoes}")
                    if investimento > 0:
                        quantidade = investimento / preco_atual
                        quantidade_ajustada, min_qty, min_notional = ajustar_quantidade_para_lot_size(quantidade, ativo)
                        
                        # Valor para verificação (agora quantidade_ajustada é string)
                        quantidade_float = float(quantidade_ajustada) if isinstance(quantidade_ajustada, str) else quantidade_ajustada
                        
                        if quantidade_float * preco_atual >= min_notional:
                            print(f"[DEBUG] Enviando ordem de compra para {ativo}: quantidade={quantidade_ajustada}, tipo={type(quantidade_ajustada)}")
                            ordem = client.order_market_buy(symbol=ativo, quantity=quantidade_ajustada)
                            
                            # Adicionar razões ao registro da operação
                            registrar_operacao(ativo, "COMPRA", quantidade_float, preco_atual, None, razoes)
                            
                            precos_compra[ativo] = preco_atual
                            posicoes_ativas[ativo] = True
                            falar_eventos("compra", ativo)
                            
                            # Atualizar o tempo da última operação
                            ultima_operacao_tempo[ativo] = tempo_atual
                            
                            # Apenas log no console
                            print(f"[COMPRA] {ativo}: {quantidade_float:.6f} @ R${preco_atual:.2f}")

            elif sinal_texto == "VENDA" and posicoes_ativas.get(ativo, False):
                quantidade_ajustada, min_qty, min_notional = ajustar_quantidade_para_lot_size(quantidade_ativo, ativo)
                print(f"[RAZÃO DA VENDA] {ativo}: {razoes}")
                
                # Valor para verificação e logs (agora quantidade_ajustada é string)
                quantidade_float = float(quantidade_ajustada) if isinstance(quantidade_ajustada, str) else quantidade_ajustada
                
                if quantidade_float > 0:
                    print(f"[DEBUG] Enviando ordem de venda para {ativo}: quantidade={quantidade_ajustada}, tipo={type(quantidade_ajustada)}")
                    ordem = client.order_market_sell(symbol=ativo, quantity=quantidade_ajustada)
                    preco_compra = precos_compra.get(ativo, 0)
                    
                    # Depois da execução, registrar a operação COM RAZÕES
                    try:
                        registrar_operacao(ativo, "VENDA", quantidade_float, preco_atual, preco_compra, razoes)
                    except Exception as e:
                        print(f"[X] Erro ao registrar operação: {e}")
                        
                    lucro = ((preco_atual - preco_compra) / preco_compra) * 100 if preco_compra > 0 else 0
                    
                    try:
                        falar_eventos("venda", ativo, lucro)
                    except Exception as e:
                        print(f"[X] Erro ao notificar venda via voz: {e}")
                        
                    print(f"[VENDA] {ativo}: {quantidade_float:.6f} @ R${preco_atual:.2f} | Lucro: {lucro:.2f}%")
                    
                    posicoes_ativas[ativo] = False
                    
                    # Atualizar o tempo da última operação
                    ultima_operacao_tempo[ativo] = tempo_atual

        except Exception as e:
            print(f"[X] Erro ao executar ordem para {ativo}: {e}")
            import traceback
            print(traceback.format_exc())
   
def garantir_colunas_previsao(X, modelo_features, silencioso=True):
    """
    Ajusta o DataFrame de entrada para corresponder exatamente 
    às features do modelo treinado, aplicando normalização de dados anômalos.

    Parâmetros:
    - X: DataFrame de entrada para previsão
    - modelo_features: Lista de features usadas no treinamento do modelo
    - silencioso: Se True, suprime mensagens de aviso

    Retorna:
    - DataFrame ajustado e sanitizado
    """
    X_ajustado = X.copy()

    # Preencher colunas ausentes
    for coluna in modelo_features:
        if coluna not in X_ajustado.columns:
            X_ajustado[coluna] = 0.0
            if not silencioso:
                print(f"[SANITIZAÇÃO] Coluna ausente adicionada: {coluna}")

    # Remover colunas extras
    colunas_validas = [col for col in modelo_features]
    X_ajustado = X_ajustado[modelo_features]

    # Normalização: forçar tipo float e eliminar NaN/inf
    X_ajustado = X_ajustado.apply(pd.to_numeric, errors='coerce').replace([np.inf, -np.inf], 0).fillna(0.0)

    return X_ajustado

def gerar_sinal_consolidado(df, ativo):
    """
    Gera um sinal de trading consolidado para um ativo,
    com explicação detalhada das razões.
    
    Retorna:
        tuple: (sinal, regime, razoes)
            - sinal: "🟢 COMPRA", "🔴 VENDA", "⚪ NEUTRO"
            - regime: "TENDÊNCIA", "LATERAL", "NEUTRO", "ALTA_VOL"
            - razoes: texto explicativo
    """

    if df is None or df.empty or len(df) < 5:
        return "⚪ NEUTRO", "DESCONHECIDO", "Dados insuficientes"

    resultado_modelo = carregar_modelo(ativo)
    if resultado_modelo and len(resultado_modelo) == 6:
        modelo, scaler, meta_info, indicadores, intervalo, regime = resultado_modelo
    else:
        return "⚪ NEUTRO", "DESCONHECIDO", "Erro ao carregar modelo"

    if modelo is None:
        return "⚪ NEUTRO", "DESCONHECIDO", "Modelo ausente"

    explicacao = [f"📊 Estratégia: Padrão ({intervalo})"]

    # Indicadores clássicos
    if "EMA_9" in df.columns and "EMA_21" in df.columns:
        ema9 = df["EMA_9"].iloc[-1]
        ema21 = df["EMA_21"].iloc[-1]
        diff_pct = ((ema9 - ema21) / abs(ema21)) * 100 if ema21 != 0 else 0
        direcao = "📈" if ema9 > ema21 else "📉"
        explicacao.append(f"📈 EMA9/21: {diff_pct:.2f}% {direcao}")

    if "RSI" in df.columns:
        rsi = df["RSI"].iloc[-1]
        if rsi < 30:
            status = "🔹 Sobrevendido"
        elif rsi > 70:
            status = "⚠️ Sobrecomprado"
        else:
            status = "Neutro"
        explicacao.append(f"🔆 RSI: {rsi:.1f} ({status})")

    if "MACD" in df.columns:
        macd = df["MACD"].iloc[-1]
        macd_prev = df["MACD"].iloc[-2] if len(df) > 1 else 0
        cruzamento = ""
        if macd > 0 and macd_prev <= 0:
            cruzamento = "✅ Cruzamento positivo"
        elif macd < 0 and macd_prev >= 0:
            cruzamento = "❌ Cruzamento negativo"
        explicacao.append(f"📊 MACD: {macd:.2f} {cruzamento}")

    # Regime
    regime_mercado = determinar_regime_mercado(df)
    if "ADX" in df.columns:
        adx = df["ADX"].iloc[-1]
        if adx > 35:
            intensidade = "🚀 tendência muito forte"
        elif adx > 25:
            intensidade = "📈 tendência forte"
        elif adx < 20:
            intensidade = "↔️ lateral"
        else:
            intensidade = "📊 fraca"
        explicacao.append(f"🧭 ADX: {adx:.1f} ({intensidade})")

    try:
        X = df.drop(columns=["timestamp", "target", "Regime"], errors="ignore").copy()
        modelo_features = modelo.feature_names_in_.tolist() if hasattr(modelo, 'feature_names_in_') else indicadores
        X_proc = garantir_colunas_previsao(X.tail(1), modelo_features, silencioso=True)

        # Executar pipeline com validação exata
        sinal, confianca = executar_pipeline_modelo(
            modelo, scaler, X_proc, modelo_features, min_confianca=0.55
        )

        explicacao.append(f"🎯 Confiança: {confianca:.1%}")
        if "NEUTRO" in sinal:
            explicacao.append(f"ℹ️ Confiança insuficiente ({confianca:.1%}) para operação")

    except Exception as e:
        print(f"[ERRO previsão {ativo}] {e}")
        sinal = "⚪ NEUTRO"
        explicacao.append("⚠️ Erro na previsão")

    razoes = " | ".join(explicacao)
    return sinal, regime_mercado, razoes


def log_exception(e, mensagem="Erro", logger=None):
    """Simplifica o log de exceções para evitar stacktraces enormes"""
    error_msg = f"{mensagem}: {str(e)}"
    if logger:
        logger.error(error_msg)
    else:
        print(f"❌ {error_msg}")

# === 07. Fluxo Principal de Execução (Loop/ciclos) === #
def calcular_tempo_espera(intervalo):
    """
    Calcula quanto tempo deve-se esperar entre operações com base
    no intervalo do modelo.
    
    Parâmetros:
    - intervalo: string com o intervalo (ex: "1h", "4h", "15m")
    
    Retorna:
    - Tempo mínimo em segundos
    """
    # Define valores padrão em minutos
    if not intervalo or intervalo == "N/A":
        return 30 * 60  # 30 minutos por padrão
    
    try:
        if "m" in intervalo:
            minutos = int(intervalo.replace("m", ""))
            return max(minutos * 60 * 0.25, 5 * 60)  # No mínimo 25% do intervalo, mas pelo menos 5 minutos
        elif "h" in intervalo:
            horas = int(intervalo.replace("h", ""))
            return max(horas * 60 * 60 * 0.25, 15 * 60)  # No mínimo 25% do intervalo, mas pelo menos 15 minutos
        else:
            return 30 * 60  # 30 minutos padrão
    except:
        return 30 * 60  # 30 minutos padrão

def carregar_modelo_indicadores(ativo):
    """
    Carrega os indicadores mais eficientes para o ativo com base no modelo salvo.
    """
    caminho_acerto = f"{MODELO_DIR}/{ativo}_taxa_acerto.json"
    if os.path.exists(caminho_acerto):
        with open(caminho_acerto, "r") as f:
            dados = json.load(f)
            return dados.get("indicadores", [])
    return []
           
def determinar_regime_mercado(df):
    """
    Determina se o mercado está em tendência ou lateralização com base no ADX.
    Retorna um dos seguintes valores: "TENDÊNCIA", "LATERAL" ou "NEUTRO".
    """
    # Verifica se o DataFrame e a coluna ADX são válidos
    if df is None or df.empty or "ADX" not in df.columns or df["ADX"].isnull().all():
        return "LATERAL"
    
    try:
        # Obter o último valor de ADX
        adx_valor = df["ADX"].iloc[-1]
        
        # Verificar se é um valor numérico válido
        if pd.isna(adx_valor) or not np.isfinite(adx_valor):
            return "LATERAL"
            
        # Converter para float se for string
        if isinstance(adx_valor, str):
            try:
                adx_valor = float(adx_valor)
            except (ValueError, TypeError):
                return "LATERAL"
        
        # Aplicar regras de classificação
        if adx_valor >= 25:
            return "TENDÊNCIA"
        elif adx_valor <= 20:
            return "LATERAL"
        else:
            return "NEUTRO"
            
    except Exception as e:
        print(f"⚠️ Erro ao determinar regime de mercado: {e}")
        return "LATERAL"
     
def exibir_indicadores_detalhados(df, ativo, intervalo=None):
    """
    Exibe os valores calculados dos indicadores e suas interpretações.
    Se um intervalo for fornecido, ele será exibido na saída.
    """
    indicadores_ativos = carregar_modelo_indicadores(ativo)

    if df is None or df.empty or len(df) < 30:
        print(f"⚠️ Poucos dados para calcular indicadores de {ativo}. Necessário pelo menos 30 candles.")
        return

    regime_mercado = determinar_regime_mercado(df)

    print("\n" + "=" * 90)
    print(f"{ativo} - Intervalo: {intervalo if intervalo else 'Desconhecido'} | Regime: {regime_mercado}")
    print("-" * 90)
    print("{:<20} | {:<15} | {}".format("Indicador", "Valor Calculado", "Interpretação"))
    print("-" * 90)

    for indicador in indicadores_ativos:
        valor = df[indicador].iloc[-1] if indicador in df.columns else "N/A"
        if isinstance(valor, (int, float)) and np.isnan(valor):
            valor = "N/A"

        interpretacao = ""
        if indicador == "EMA_9" and "EMA_21" in df.columns:
            interpretacao = "🔼 Alta" if df["EMA_9"].iloc[-1] > df["EMA_21"].iloc[-1] else "🔽 Baixa"
        if indicador == "RSI":
            if isinstance(valor, (int, float)):
                interpretacao = "🟢 Sobrevendido (< 30)" if valor < 30 else "🔴 Sobrecomprado (> 70)" if valor > 70 else ""
        if indicador == "OBV":
            interpretacao = "📈 Alta" if df["OBV"].diff().iloc[-1] > 0 else "📉 Baixa"
        if indicador == "ADX":
            interpretacao = "📈 Forte tendência" if valor > 25 else "📊 Mercado lateral"

        print("{:<20} | {:<15} | {}".format(indicador, round(valor, 2) if isinstance(valor, (int, float)) else valor, interpretacao))

    print("-" * 90)
    print("=" * 90)

ultimo_relatorio = None  # Inicializa a variável para evitar NameError

def exibir_sinais(dados_sinais):
    """
    Exibe a tabela de sinais consolidados com formatação otimizada
    baseada em larguras fixas de colunas.
    """
    print("\n🚀 [SINAIS CONSOLIDADOS] 🚀")
    
    # Preparar dados para tabela
    tabela = []
    LARGURA_MAX_INDICADORES = 25  # Define tamanho máximo para coluna de indicadores
    
    for ativo, posicao, indicadores_texto, sinal, regime in dados_sinais:
        # Obter info do modelo
        _, _, _, _, intervalo, _ = carregar_modelo(ativo)
        
        # Processar indicadores - truncar se necessário
        if isinstance(indicadores_texto, str):
            ind_texto = indicadores_texto
        elif isinstance(indicadores_texto, list):
            ind_texto = ", ".join(indicadores_texto)
        else:
            ind_texto = ""
            
        # Truncar indicadores se excederem o tamanho máximo
        if len(ind_texto) > LARGURA_MAX_INDICADORES:
            ind_texto = ind_texto[:LARGURA_MAX_INDICADORES-3] + "..."
        
        # Calcular lucro
        preco_compra = precos_compra.get(ativo, 0)
        try:
            preco_atual = float(client.get_symbol_ticker(symbol=ativo)["price"])
            lucro_percentual = ((preco_atual - preco_compra) / preco_compra) * 100 if preco_compra > 0 else 0
            lucro_real = (preco_atual - preco_compra) * float(saldos_disponiveis.get(ativo.replace("BRL", ""), 0))
        except:
            lucro_percentual = 0
            lucro_real = 0
        
        # Garantir regime limpo (sem espaços extras)
        regime_limpo = regime.strip() if isinstance(regime, str) else "NEUTRO"
        
        # Adicionar linha à tabela
        tabela.append([
            ativo,
            posicao,
            intervalo,
            ind_texto,
            sinal,
            regime_limpo,
            f"{lucro_percentual:.2f}",  # Formatado como string para controle preciso
            f"R$ {lucro_real:.2f}"
        ])
    
    # Definir cabeçalhos
    headers = ["ATIVO", "POSIÇÃO", "INTERVALO", "INDICADORES", "SINAL", "REGIME", "LUCRO (%)", "LUCRO (R$)"]
    
    # Definir alinhamento específico para cada coluna
    alinhamentos = ['center', 'center', 'center', 'left', 'center', 'center', 'right', 'right']
    
    # Usar tabulate com configurações específicas
    from tabulate import tabulate
    tabela_formatada = tabulate(
        tabela,
        headers=headers,
        tablefmt='simple',
        colalign=alinhamentos,
        stralign='center',
        numalign='right'
    )
    
    # Personalização adicional - substituir caracteres de linha para melhor aparência
    tabela_formatada = tabela_formatada.replace('-', '═')
    tabela_formatada = tabela_formatada.replace('+', '╬')
    
    # Imprimir tabela
    print(tabela_formatada)
    
    # Mostrar informações de saldo
    saldo_brl = saldos_disponiveis.get("BRL", 0)
    investimento_por_ativo = saldos_disponiveis.get("investimento_por_ativo", 0)
    print(f"\n💰 Saldo BRL: R${saldo_brl:.2f} | Investimento por ativo: R${investimento_por_ativo:.2f}")

def exibir_sinais_manual(dados_sinais, modelos_info=None):
    """
    Exibe a tabela de sinais consolidados com alinhamento visual corrigido,
    mesmo com uso de cores ANSI e emojis.
    """
    import re

    if modelos_info is None:
        modelos_info = {}

    # Se não houver dados, não exibe a tabela
    if not dados_sinais:
        print("\n\033[1;33m⚠️ Nenhum sinal disponível para exibição\033[0m")
        return

    def largura_visual(texto):
        # Remove códigos ANSI para calcular o comprimento real
        return len(re.sub(r'\x1b[^m]*m', '', texto))

    def ajustar_largura(texto, largura):
        visivel = largura_visual(texto)
        return texto + ' ' * max(0, largura - visivel)

    # Larguras fixas por coluna
    COL_ATIVO = 8
    COL_POSICAO = 10
    COL_INTERVALO = 8
    COL_INDICADORES = 25
    COL_SINAL = 10
    COL_REGIME = 12
    COL_RAZOES = 50

    print("\n\033[1;36m🚀 [SINAIS CONSOLIDADOS] 🚀\033[0m")
    print("┌" + "─" * COL_ATIVO + "┬" + "─" * COL_POSICAO + "┬" + "─" * COL_INTERVALO +
          "┬" + "─" * COL_INDICADORES + "┬" + "─" * COL_SINAL + "┬" + "─" * COL_REGIME +
          "┬" + "─" * COL_RAZOES + "┐")

    cabecalhos = ["ATIVO", "POSIÇÃO", "INTERV.", "INDICADORES", "SINAL", "REGIME", "RAZÕES"]
    larguras = [COL_ATIVO, COL_POSICAO, COL_INTERVALO, COL_INDICADORES, COL_SINAL, COL_REGIME, COL_RAZOES]

    linha_cabecalho = "│" + "│".join(
        [ajustar_largura(f"\033[1m{cab.center(w)}\033[0m", w) for cab, w in zip(cabecalhos, larguras)]
    ) + "│"
    print(linha_cabecalho)

    print("├" + "─" * COL_ATIVO + "┼" + "─" * COL_POSICAO + "┼" + "─" * COL_INTERVALO +
          "┼" + "─" * COL_INDICADORES + "┼" + "─" * COL_SINAL + "┼" + "─" * COL_REGIME +
          "┼" + "─" * COL_RAZOES + "┤")

    # Verificar se temos dados para exibir
    if len(dados_sinais) == 0:
        linha_vazia = "│" + " " * COL_ATIVO + "│" + " " * COL_POSICAO + "│" + " " * COL_INTERVALO + "│" + \
                    " " * COL_INDICADORES + "│" + " " * COL_SINAL + "│" + " " * COL_REGIME + "│" + \
                    " Nenhum sinal disponível " + " " * (COL_RAZOES - 24) + "│"
        print(linha_vazia)
    else:
        for item in dados_sinais:
            try:
                # Garantir 6 elementos em cada item
                if len(item) < 6:
                    item = list(item)
                    while len(item) < 6:
                        item.append("")
                
                ativo, posicao, indicadores_texto, sinal, regime, razoes = item[:6]
                
                # Garantir que todos os valores são strings
                ativo = str(ativo) if ativo is not None else ""
                posicao = str(posicao) if posicao is not None else ""
                sinal = str(sinal) if sinal is not None else ""
                regime = str(regime) if regime is not None else ""
                razoes = str(razoes) if razoes is not None else ""
                
                # Obter informações do modelo
                intervalo = modelos_info.get(ativo, "N/A")
                
                # Processar indicadores
                if isinstance(indicadores_texto, list):
                    ind_texto = ", ".join(indicadores_texto[:3])
                    if len(indicadores_texto) > 3:
                        ind_texto += "..."
                else:
                    ind_texto = str(indicadores_texto)
                
                # Truncar textos longos
                ind_texto = ind_texto[:COL_INDICADORES-3] + "..." if len(ind_texto) > COL_INDICADORES else ind_texto
                razoes_formatada = razoes[:COL_RAZOES-3] + "..." if len(razoes) > COL_RAZOES else razoes
                
                # Cores
                ativo_c = f"\033[1;33m{ativo.center(COL_ATIVO)}\033[0m"
                posicao_c = f"\033[1;32m{posicao.center(COL_POSICAO)}\033[0m" if "SIM" in posicao else f"\033[1;31m{posicao.center(COL_POSICAO)}\033[0m"
                sinal_c = f"\033[1;32m{sinal.center(COL_SINAL)}\033[0m" if "COMPRA" in sinal else f"\033[1;31m{sinal.center(COL_SINAL)}\033[0m" if "VENDA" in sinal else f"\033[1;37m{sinal.center(COL_SINAL)}\033[0m"
                regime_c = f"\033[1;34m{regime.center(COL_REGIME)}\033[0m" if "TENDÊNCIA" in regime else f"\033[1;33m{regime.center(COL_REGIME)}\033[0m" if "LATERAL" in regime else f"\033[1;37m{regime.center(COL_REGIME)}\033[0m"
                
                linha = "│" + "│".join([
                    ajustar_largura(ativo_c, COL_ATIVO),
                    ajustar_largura(posicao_c, COL_POSICAO),
                    ajustar_largura(intervalo.center(COL_INTERVALO), COL_INTERVALO),
                    ajustar_largura(ind_texto, COL_INDICADORES),
                    ajustar_largura(sinal_c, COL_SINAL),
                    ajustar_largura(regime_c, COL_REGIME),
                    ajustar_largura(razoes_formatada, COL_RAZOES)
                ]) + "│"
                
                print(linha)
                
            except Exception as e:
                print(f"│ Erro ao processar item: {str(e)[:COL_ATIVO + COL_POSICAO + COL_INTERVALO + COL_INDICADORES + COL_SINAL + COL_REGIME + COL_RAZOES - 25]} │")

    print("└" + "─" * COL_ATIVO + "┴" + "─" * COL_POSICAO + "┴" + "─" * COL_INTERVALO +
          "┴" + "─" * COL_INDICADORES + "┴" + "─" * COL_SINAL + "┴" + "─" * COL_REGIME +
          "┴" + "─" * COL_RAZOES + "┘")

    saldo_brl = saldos_disponiveis.get("BRL", 0)
    investimento_por_ativo = saldos_disponiveis.get("investimento_por_ativo", 0)
    print(f"\n\033[1;32m💰 Saldo BRL: R${saldo_brl:.2f}\033[0m | \033[1;36mInvestimento por ativo: R${investimento_por_ativo:.2f}\033[0m")

def enviar_relatorio_diario(modo_forcado=False):
    """
    Envia os resumos de performance por período.
    
    Parâmetros:
    - modo_forcado: Se True, envia todos os relatórios independente da programação horária
    
    Programação normal (quando modo_forcado=False):
    - Ano: 1x ao dia, às 08h
    - Mês: 2x ao dia, às 08h e 20h
    - Semana: 4x ao dia (02h, 08h, 14h, 20h)
    - Diário: a cada 1h
    """
    import traceback
    import sqlite3
    import os
    import time

    global historico_resumos_enviados, historico_saldos
    if 'historico_resumos_enviados' not in globals():
        historico_resumos_enviados = {"ano": None, "mes": None, "semana": None, "dia": None}
    
    if 'historico_saldos' not in globals():
        historico_saldos = {"ano": None, "mes": None, "semana": None, "dia": None}

    agora = datetime.now()
    hora = agora.hour

    # Determina quais relatórios devem ser enviados
    if modo_forcado:
        # No modo forçado, envia todos os relatórios
        print("📤 Enviando todos os resumos forçados...")
        enviar_ano = enviar_mes = enviar_semana = enviar_dia = True
    else:
        # No modo normal, verifica o horário para cada relatório
        def pode_enviar(periodo, janelas_horas):
            ultima = historico_resumos_enviados.get(periodo)
            if hora in janelas_horas and (not ultima or ultima.date() != agora.date() or ultima.hour != hora):
                historico_resumos_enviados[periodo] = agora
                return True
            return False
        
        # Programação normal de envios
        enviar_ano = pode_enviar("ano", [8])
        enviar_mes = pode_enviar("mes", [8, 20])
        enviar_semana = pode_enviar("semana", [2, 8, 14, 20])
        enviar_dia = pode_enviar("dia", list(range(24)))  # Sempre que a hora mudar
        
        if not any([enviar_ano, enviar_mes, enviar_semana, enviar_dia]):
            return  # Nenhum envio neste momento

    # Obter dados atuais
    try:
        # Garantir que os saldos estão atualizados
        listar_saldos(modo_silencioso=True)
    except Exception as e:
        print(f"⚠️ Erro ao atualizar saldos: {e}")

    saldo_brl = saldos_disponiveis.get("BRL", 0)
    total_ativos = 0
    valor_ativos = 0
    
    try:
        for ativo in ativos:
            base = ativo.replace("BRL", "").replace("USDT", "")
            qtd = saldos_disponiveis.get(base, 0)
            try:
                preco = float(client.get_symbol_ticker(symbol=ativo)["price"])
                valor_ativos += qtd * preco
                total_ativos += 1
            except Exception as e:
                if modo_forcado:  # Log mais detalhado no modo forçado
                    print(f"⚠️ Erro ao obter preço para {ativo}: {e}")
                continue
    except Exception as e:
        print(f"⚠️ Erro ao calcular valor dos ativos: {e}")
        
    saldo_total = saldo_brl + valor_ativos
    
    if modo_forcado:
        print(f"💰 Saldo atual: BRL={saldo_brl:.2f}, Ativos={valor_ativos:.2f}, Total={saldo_total:.2f}")

    # Função para buscar dados históricos de operações do banco/arquivo
    
    def obter_saldo_historico(dias_atras, periodo):
        """
        Tenta obter um saldo histórico de X dias atrás, baseado em operações registradas.
        Retorna o saldo estimado do período.
        """
        data_referencia = agora - timedelta(days=dias_atras)
        
        # Método 1: Tentar buscar do banco de dados de operações
        if os.path.exists(DB_PATH):
            try:
                conn = sqlite3.connect(DB_PATH)
                cursor = conn.cursor()
                
                # Consulta para somar valores de operações até a data
                cursor.execute("""
                SELECT SUM(CASE WHEN operacao = 'COMPRA' THEN -valor_total ELSE valor_total END) 
                FROM operacoes 
                WHERE data > ?
                """, (data_referencia.strftime("%Y-%m-%d %H:%M:%S"),))
                
                resultado = cursor.fetchone()
                conn.close()
                
                if resultado and resultado[0] is not None:
                    # O saldo em BRL mudou por esse valor desde a data de referência
                    variacao_desde_referencia = float(resultado[0])
                    # O saldo anterior seria o atual menos a variação
                    saldo_historico = saldo_total - variacao_desde_referencia
                    if modo_forcado:
                        print(f"📊 Dados históricos (BD) para {periodo}: {saldo_historico:.2f}")
                    return saldo_historico
            except Exception as e:
                if modo_forcado:
                    print(f"⚠️ Erro ao buscar saldo histórico do banco: {e}")
        
        # Método 2: Tentar buscar do arquivo CSV
        if os.path.exists(HISTORICO_ARQUIVO):
            try:
                import csv
                
                # Calcular o impacto total de operações após a data de referência
                variacao_desde_referencia = 0
                operacoes_encontradas = False
                
                with open(HISTORICO_ARQUIVO, 'r', newline='') as f:
                    reader = csv.reader(f)
                    next(reader)  # Pular cabeçalho
                    
                    for row in reader:
                        try:
                            data_op = datetime.strptime(row[0], "%Y-%m-%d %H:%M:%S")
                            if data_op > data_referencia:
                                valor_total = float(row[5])
                                operacao = row[2]
                                # COMPRA diminui saldo, VENDA aumenta
                                if operacao == "COMPRA":
                                    variacao_desde_referencia -= valor_total
                                else:
                                    variacao_desde_referencia += valor_total
                                operacoes_encontradas = True
                        except (ValueError, IndexError):
                            continue
                
                if operacoes_encontradas:
                    # O saldo anterior seria o atual menos a variação
                    saldo_historico = saldo_total - variacao_desde_referencia
                    if modo_forcado:
                        print(f"📊 Dados históricos (CSV) para {periodo}: {saldo_historico:.2f}")
                    return saldo_historico
            except Exception as e:
                if modo_forcado:
                    print(f"⚠️ Erro ao buscar saldo histórico do CSV: {e}")
        
        # Método 3: Usar histórico já registrado anteriormente
        if periodo in historico_saldos and historico_saldos[periodo] is not None:
            if modo_forcado:
                print(f"📊 Usando histórico salvo para {periodo}: {historico_saldos[periodo]:.2f}")
            return historico_saldos[periodo]
            
        # Método 4: Usar saldo atual com desconto estimado (último recurso)
        saldo_estimado = None
        if dias_atras > 180:  # Ano
            saldo_estimado = saldo_total * 0.85  # Estima 15% menos que o atual
        elif dias_atras > 90:  # Semestre
            saldo_estimado = saldo_total * 0.92  # Estima 8% menos que o atual
        elif dias_atras > 30:  # Mês
            saldo_estimado = saldo_total * 0.96  # Estima 4% menos que o atual
        elif dias_atras > 7:   # Semana 
            saldo_estimado = saldo_total * 0.98  # Estima 2% menos que o atual
        else:
            saldo_estimado = saldo_total * 0.99  # Estima 1% menos que o atual
            
        if modo_forcado:
            print(f"📊 Usando valor estimado para {periodo}: {saldo_estimado:.2f}")
            
        return saldo_estimado

    # Definir períodos de busca para cada tipo de relatório
    dias_por_periodo = {
        "dia": 1,        # 1 dia atrás
        "semana": 7,     # 7 dias atrás
        "mes": 30,       # 30 dias atrás
        "ano": 365       # 365 dias atrás
    }

    # Enviar relatórios com variação por período
    periodos_para_enviar = [
        ("ano", enviar_ano), 
        ("mes", enviar_mes), 
        ("semana", enviar_semana), 
        ("dia", enviar_dia)
    ]
    
    for periodo, condicao_envio in periodos_para_enviar:
        if condicao_envio:
            try:
                # Busca saldo histórico com base no período
                dias_atras = dias_por_periodo[periodo]
                #saldo_historico = obter_saldo_historico(dias_atras, periodo)
                # Gerar chave única por período
                if periodo == "dia":
                    chave = agora.strftime("%Y-%m-%d")
                elif periodo == "semana":
                    chave = f"{agora.year}-W{agora.isocalendar()[1]}"
                elif periodo == "mes":
                    chave = agora.strftime("%Y-%m")
                elif periodo == "ano":
                    chave = str(agora.year)

                # Utiliza saldo inicial fixo por período
                saldo_historico = obter_saldo_inicial_fixo(periodo, chave, saldo_total)

                
                if saldo_historico is None:
                    # Se não encontrar histórico, usar o saldo atual (variação será zero)
                    saldo_historico = saldo_total
                
                # Salvar como último valor conhecido para este período
                historico_saldos[periodo] = saldo_total  # Atualiza para a próxima execução
                
                variacao_valor = saldo_total - saldo_historico
                variacao_pct = (variacao_valor / saldo_historico) * 100 if saldo_historico != 0 else 0
                emoji_var = "🟢" if variacao_valor > 0 else "🔴" if variacao_valor < 0 else "⚪"

                mensagem = f"💹 *Resumo de Performance ({periodo.upper()})*\n"
                mensagem += f"💰 *Saldo Inicial:* R$ {saldo_historico:.2f}\n"
                mensagem += f"💰 *Saldo Total:* R$ {saldo_total:.2f}\n"
                mensagem += f"📊 *Saldo BRL:* R$ {saldo_brl:.2f}\n"
                mensagem += f"📊 *Saldo Ativos:* R$ {valor_ativos:.2f}\n"
                mensagem += f"{emoji_var} *Variação:* {variacao_valor:+.2f} BRL ({variacao_pct:+.2f}%)\n"
                mensagem += f"🕒 *Hora:* {agora.strftime('%d/%m/%Y %H:%M')}"

                if modo_forcado:
                    print(f"Enviando resumo de {periodo}...")
                    # Adicionar delay para evitar flood de mensagens no modo forçado
                    time.sleep(1)
                
                enviar_mensagem_telegram(
                    f"\n\n📅 *Resumo {periodo.capitalize()}*\n{mensagem}",
                    nivel="importante", 
                    bypass_frequency=True
                )
                
                if modo_forcado:
                    print(f"✅ Resumo de {periodo} enviado com sucesso!")
            
            except Exception as e:
                print(f"❌ Erro ao enviar resumo de {periodo}: {e}")
                if modo_forcado:
                    print(traceback.format_exc())

# Função auxiliar para chamada forçada (apenas para compatibilidade)
def enviar_relatorio_diario_forcado():
    """
    Função de compatibilidade que apenas chama enviar_relatorio_diario
    em modo forçado.
    """
    return enviar_relatorio_diario(modo_forcado=True)

def enviar_boletim_aprendizado():
    """
    Gera e envia um resumo semanal da evolução dos modelos.
    """
    mensagens = []
    for ativo in ativos:
        try:
            _, _, meta, indicadores, intervalo, _ = carregar_modelo(ativo)
            score = meta.get("score", 0)
            timestamp = meta.get("timestamp", "N/A")
            mensagens.append(f"📈 {ativo}: Score: {score:.2f} | Intervalo: {intervalo} | Atualizado em: {timestamp}")
        except:
            mensagens.append(f"❌ {ativo}: Modelo não carregado.")

    mensagem = "*🧠 Boletim Semanal de Modelos*\n\n" + "\n".join(mensagens)
    enviar_mensagem_telegram(mensagem, nivel="importante", bypass_frequency=True)


# === 08. Registro de operações === #
def salvar_logs_detalhados(max_ciclos=5):
    """
    Captura e salva os logs completos dos primeiros X ciclos de execução.
    Parâmetros:
    - max_ciclos: Número máximo de ciclos para salvar logs detalhados
    """
    import os
    import sys
    from io import StringIO
    
    # Criar pasta para logs detalhados se não existir
    logs_dir = "logs_detalhados"
    os.makedirs(logs_dir, exist_ok=True)
    
    # Variáveis para controle do ciclo atual
    ciclo_atual = 0
    max_ciclos_ativos = max_ciclos
    log_buffer = None
    original_stdout = None
    arquivo_log_atual = None
    timestamp_inicio = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Função para iniciar a captura de logs de um ciclo
    def iniciar_captura_ciclo():
        nonlocal log_buffer, original_stdout, arquivo_log_atual, ciclo_atual
        ciclo_atual += 1
        print(f" Iniciando captura detalhada do ciclo #{ciclo_atual}")
        
        # Nome do arquivo de log para este ciclo
        arquivo_log_atual = os.path.join(
            logs_dir,
            f"log_detalhado_IA_ciclo_{ciclo_atual}_{timestamp_inicio}.txt"
        )
        
        # Iniciar captura do stdout
        log_buffer = StringIO()
        original_stdout = sys.stdout
        sys.stdout = log_buffer
        
        # Cabeçalho do log
        print("="*80)
        print(f"LOG DETALHADO - CICLO {ciclo_atual} - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("="*80)
        print(f"Configuração de ambiente:")
        print(f"- Python: {sys.version}")
        print(f"- Diretório atual: {os.getcwd()}")
        print(f"- Timestamp de início: {timestamp_inicio}")
        print("="*80)
    
    # Função para finalizar a captura de logs do ciclo atual
    def finalizar_captura_ciclo():
        nonlocal log_buffer, original_stdout, arquivo_log_atual, ciclo_atual
        if log_buffer is not None and original_stdout is not None:
            # Restaurar stdout original
            sys.stdout = original_stdout
            
            # Rodapé do log
            log_buffer.write("\n" + "="*80 + "\n")
            log_buffer.write(f"FIM DO LOG - CICLO {ciclo_atual} - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            log_buffer.write("="*80 + "\n")
            
            # Salvar o buffer no arquivo
            with open(arquivo_log_atual, 'w', encoding='utf-8') as f:
                f.write(log_buffer.getvalue())
                
            print(f" Log detalhado do ciclo #{ciclo_atual} salvo em: {arquivo_log_atual}")
            
            # Limpar buffer
            log_buffer.close()
            log_buffer = None
        #else:
        #    print(f" Aviso: Tentativa de finalizar captura sem inicialização prévia")
    
    # Função para verificar se devemos continuar capturando
    def deve_capturar():
        return ciclo_atual < max_ciclos_ativos
    
    # Retornar as funções de controle como um dicionário
    return {
        'iniciar_captura': iniciar_captura_ciclo,
        'finalizar_captura': finalizar_captura_ciclo,
        'deve_capturar': deve_capturar,
        'ciclo_atual': lambda: ciclo_atual
    }    

def monitorar():
    """
    Loop principal que monitora os ativos, calcula indicadores,
    gera sinais e executa operações com tratamento de erros melhorado.
    Agora com envio automático de resumo horário ao Telegram.
    """

    # Verificar se a comunicação com Telegram está funcionando
    print("Testando conexão com Telegram...")
    try:
        #enviar_mensagem_telegram("🔄 Teste de comunicação com Telegram", nivel="alerta")
        print("✅ Comunicação com Telegram OK")
    except Exception as e:
        print(f"❌ Erro na comunicação com Telegram: {e}")
        import traceback
        print(traceback.format_exc())

    # Informe de início do código
    enviar_mensagem_telegram("🚀 Sistema de monitoramento iniciado com sucesso", nivel="importante", bypass_frequency=True)

    import time
    import pandas as pd
    import numpy as np

    # ✅ Corrige possível erro: criar pasta para o log principal
    os.makedirs("logs_execucao", exist_ok=True)

    # ✅ Redefine handler para salvar apenas em arquivo, sem log no console
    logger = logging.getLogger("trading")
    logger.setLevel(logging.INFO)

    file_handler = logging.FileHandler("logs_execucao/execucao_IA.txt", encoding='utf-8')
    file_handler.setFormatter(logging.Formatter("%(asctime)s - %(message)s"))
    logger.handlers = [file_handler]  # Apenas em arquivo

    # Logger de exceções
    loggers = configurar_logging()
    log_exception = loggers['log_exception']

    captura_logs = salvar_logs_detalhados(max_ciclos=5)

    try:
        ATIVOS = ["BTCBRL", "ETHBRL", "DOGEBRL", "SOLBRL", "XRPBRL"]

        if 'falar' in globals():
            falar("Sistema de trading iniciado")

        inicializar_bd()
        inicializar_historico()

        global ultima_atualizacao_modelo_por_ativo, modelos_info, ultimo_relatorio
        if 'ultima_atualizacao_modelo_por_ativo' not in globals():
            ultima_atualizacao_modelo_por_ativo = {}

        listar_saldos(modo_silencioso=True)
        ultimo_relatorio = datetime.now()

        try:
            enviar_relatorio_diario_forcado()
        except Exception as e:
            log_exception(e, "Erro ao enviar relatório diário no início")

        modelos_info = {}
        tempo_minimo_entre_operacoes = {}

        for ativo in ATIVOS:
            try:
                _, _, _, _, intervalo, _ = carregar_modelo(ativo)
                tempo_minimo_entre_operacoes[ativo] = calcular_tempo_espera(intervalo)
            except Exception as e:
                log_exception(e, f"Erro ao inicializar tempo mínimo para {ativo}")
                tempo_minimo_entre_operacoes[ativo] = 30 * 60

        ciclo = 0
        while True:
            ciclo += 1
            agora = datetime.now()

            # ✅ Divisória de início de ciclo no console
            print("\n" + "="*80)
            print(f"🚀 INICIANDO CICLO {ciclo} às {agora.strftime('%d/%m/%Y %H:%M:%S')}")
            print("="*80 + "\n")

            if captura_logs['deve_capturar']():
                captura_logs['iniciar_captura']()

            inicio_ciclo = datetime.now()
            logger.info(f"Iniciando ciclo {ciclo} de monitoramento às {inicio_ciclo.strftime('%H:%M:%S')}")

            try:
                # ✅ Resumo a cada hora
                agora = datetime.now()
                if ultimo_relatorio is None or (agora - ultimo_relatorio).total_seconds() >= 3600:
                    enviar_relatorio_diario()
                    ultimo_relatorio = agora
                    logger.info("📤 Resumo horário enviado ao Telegram.")

                # Enviar boletim semanal aos domingos às 09:00
                if agora.weekday() == 6 and agora.hour == 9:
                    enviar_boletim_aprendizado()
                    
            except Exception as e:
                log_exception(e, "Erro ao enviar relatório periódico")

            try:
                dados_mercado, novos_modelos_info = buscar_dados_binance(ATIVOS, modo_silencioso=True)

                # Verificação de atualizações e exibição compacta
                modelos_carregados_linha = []
                for ativo in ATIVOS:
                    novo_intervalo = novos_modelos_info.get(ativo, "N/A")
                    intervalo_anterior = modelos_info.get(ativo)

                    # Verifica se houve alteração do intervalo
                    houve_atualizacao = intervalo_anterior and intervalo_anterior != novo_intervalo
                    simbolo = "🌟" if houve_atualizacao else "✅"

                    modelos_carregados_linha.append(f"{simbolo} {ativo} ({novo_intervalo})")

                # Atualiza os modelos_info com os novos
                modelos_info.update(novos_modelos_info)

                # Exibe em linha
                linha_formatada = " | ".join(modelos_carregados_linha)
                print(f"\n🧠 Modelos carregados: {linha_formatada}\n")

                if not dados_mercado:
                    logger.warning("Nenhum dado de mercado recebido. Pulando ciclo.")
                    time.sleep(60)
                    if captura_logs['ciclo_atual']() <= 5:
                        captura_logs['finalizar_captura']()
                    continue

                dados_sinais = []
                for ativo in ATIVOS:
                    try:
                        df = dados_mercado.get(ativo)
                        if df is None or df.empty:
                            print(f"⚠️ Dados vazios para {ativo}, pulando...")
                            continue

                        # Verificar se as colunas necessárias existem
                        if not all(col in df.columns for col in ['close', 'high', 'low', 'volume']):
                            print(f"⚠️ Colunas necessárias ausentes para {ativo}")
                            continue

                        # Importante: Garantir que o DataFrame tem as colunas necessárias para o cálculo dos indicadores
                        df_proc = df.copy()
                        
                        # Calcular indicadores técnicos
                        #print(f"🔢 Calculando indicadores para {ativo}...")
                        df_proc = calcular_indicadores(df_proc, ativo, silencioso=False)  # Defina como False para ver os logs
                        
                        # Calcular regime de mercado
                        df_proc = calcular_regime_mercado(df_proc)
                        
                        # Sanitizar o DataFrame para remover possíveis valores problemáticos
                        df_proc = sanitizar_dataframe(df_proc)
                        
                        registrar_distribuicao_features(ativo, df_proc)

                        # Verificar se os indicadores foram calculados
                        if 'EMA_9' not in df_proc.columns or 'RSI' not in df_proc.columns:
                            print(f"⚠️ Indicadores não foram calculados para {ativo}. Colunas: {df_proc.columns.tolist()}")
                            continue
                        
                        #print(f"📊 Gerando sinal para {ativo} com indicadores...")
                        sinal, regime, razoes = gerar_sinal_consolidado(df_proc, ativo)
                        posicao = "✅ SIM" if (posicoes_ativas.get(ativo, False)) else "🛑 NÃO"
                        _, _, _, indicadores, _, _ = carregar_modelo(ativo)
                        
                        dados_sinais.append([ativo, posicao, indicadores, sinal, regime, razoes])
                        #print(f"✅ Sinal gerado para {ativo}: {sinal}, regime: {regime}")
                        
                    except Exception as e:
                        log_exception(e, f"Erro ao processar {ativo}")
                        print(f"❌ Erro ao processar {ativo}: {str(e)}")

                # Exibir os sinais na tabela
                exibir_sinais_manual(dados_sinais, modelos_info)
                executar_ordens(dados_sinais)
                
                # 🔄 Aprendizado retroativo com base no histórico
                for ativo in ATIVOS:
                    try:
                        retroalimentar_com_csv(ativo)
                    except Exception as e:
                        log_exception(e, f"Erro na retroalimentação do modelo {ativo}")

            except Exception as e:
                log_exception(e, "Erro no ciclo principal de monitoramento")
                print(f"❌ Erro no ciclo principal: {str(e)}")

            fim_ciclo = datetime.now()
            duracao_ciclo = (fim_ciclo - inicio_ciclo).total_seconds()
            tempo_espera = max(60 - duracao_ciclo, 5)

            logger.info(f"Ciclo {ciclo} concluído em {duracao_ciclo:.1f}s. Aguardando {tempo_espera:.0f}s...")

            if captura_logs['ciclo_atual']() <= 5:
                captura_logs['finalizar_captura']()

            time.sleep(tempo_espera)

    except KeyboardInterrupt:
        if captura_logs['ciclo_atual']() <= 5:
            captura_logs['finalizar_captura']()
        logger.info("Interrupção manual do sistema.")
        enviar_mensagem_telegram("⚠️ Sistema interrompido manualmente.", nivel="alerta", bypass_frequency=True)

    except Exception as e:
        if captura_logs['ciclo_atual']() <= 5:
            captura_logs['finalizar_captura']()
        log_exception(e, "Erro crítico no sistema")
        enviar_mensagem_telegram(f"🚨 Sistema parado por erro crítico: {str(e)[:100]}...", nivel="alerta", bypass_frequency=True)
        print("\n ESTADO DOS MODELOS AO FINAL DO CICLO:")
        exibir_modelos_vigentes(f"CICLO {ciclo} - FINAL")
        logger.error("Tentando reiniciar em 5 minutos...")
        time.sleep(300)
        monitorar()

if __name__ == "__main__":
    # Inicializa banco de dados e histórico
    inicializar_bd()
    inicializar_historico()
    
    # Inicia monitoramento
    monitorar()


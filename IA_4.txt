# === 00. IMPORTS === #
import requests
import pandas as pd
import numpy as np
import time
import pyttsx3
import joblib
import itertools
import os
import json
import pickle
import ast
import timeit
import sqlite3
import difflib
import csv
import re
import logging
from sklearn.metrics import accuracy_score
from binance.client import Client
from binance.enums import *
from datetime import datetime
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.ensemble import RandomForestClassifier
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.neural_network import MLPClassifier
from sklearn.model_selection import StratifiedKFold
from datetime import datetime, timedelta
from ta.trend import EMAIndicator, MACD
from ta.momentum import RSIIndicator
from ta.volume import OnBalanceVolumeIndicator
from ta.volatility import BollingerBands
from ta.utils import dropna
from ta.trend import ADXIndicator
from ta.volatility import AverageTrueRange
from ta.volume import VolumeWeightedAveragePrice
from tpot import TPOTClassifier
from imblearn.over_sampling import SMOTE
from dotenv import load_dotenv
from tabulate import tabulate
from database import salvar_operacao
from database import salvar_performance_modelo
from tabulate import tabulate
from imblearn.over_sampling import SMOTE
from decimal import Decimal
from Backtest_IA import exibir_modelos_vigentes
from sklearn.metrics import accuracy_score
import logging
import warnings
import sys
import io
import locale

# Adicione isso no in√≠cio do seu c√≥digo, ap√≥s os imports
# Silenciar warnings espec√≠ficos
warnings.filterwarnings("ignore", category=UserWarning, module="sklearn")
warnings.filterwarnings("ignore", category=FutureWarning)
logging.getLogger("sklearn").setLevel(logging.ERROR)
logging.getLogger("joblib").setLevel(logging.ERROR)

from utils import enviar_mensagem_telegram, calcular_indicadores, sanitizar_dataframe, calcular_regime_mercado, enviar_resumo_consolidado, notificar_modelo_carregado, criar_metrica_composta
from utils import executar_pipeline_modelo

# Substitua a configura√ß√£o atual do sistema de sa√≠da por:
# For√ßa UTF-8 no Windows

# For√ßa UTF-8 em todos os sistemas
sys.stdout = io.TextIOWrapper(sys.stdout.buffer, encoding='utf-8', errors='replace')
sys.stderr = io.TextIOWrapper(sys.stderr.buffer, encoding='utf-8', errors='replace')

logger = logging.getLogger("trading")
logger.setLevel(logging.INFO)

# ‚úÖ Garante que a pasta logs_execucao existe
os.makedirs("logs_execucao", exist_ok=True)

# Configura handler para arquivo
file_handler = logging.FileHandler("logs_execucao/execucao_IA.txt", encoding='utf-8')
file_handler.setFormatter(logging.Formatter("%(asctime)s - %(message)s"))

# Remove todos os handlers existentes
logger.handlers.clear()

# Aplica apenas o handler de arquivo (n√£o envia nada para o console)
logger.addHandler(file_handler)

warnings.filterwarnings("ignore", category=FutureWarning)
logging.getLogger("sklearn").setLevel(logging.ERROR)
logging.getLogger("joblib").setLevel(logging.ERROR)

# === CONFIGURA√á√ïES GERAIS ===
DB_PATH = "trading_ai.db"
HISTORICO_ARQUIVO = "historico_operacoes_OPs.csv"

# Diret√≥rio para armazenar os modelos
MODELO_DIR = "modelos"
os.makedirs(MODELO_DIR, exist_ok=True)

# === 01. Configura√ß√µes Gerais === #
# Binance Configura√ß√µes
API_KEY = "bliOJOLnQPjswLvWc1AU8Ssl9lsd1VOxO2xz8f8WrF5JEBfYpMmKjVgIyse6ux6i"
SECRET_KEY = "FABfMA13D08nPN4ye7RUO1IcZrgoh9wYWTCAlK0C3OYvizs1iP45SHjR4DgVT2xK"
client = Client(API_KEY, SECRET_KEY)

# Ativos Monitorados
ativos = ["BTCBRL", "ETHBRL", "DOGEBRL", "SOLBRL", "XRPBRL"]
#ativos = ["BTCBRL", "ETHBRL", "DOGEBRL", "SOLBRL", "XRPBRL", "USUALUSDT"]
#periodo_candle = Client.KLINE_INTERVAL_5MINUTE

# Inicializa o engine de voz
engine = pyttsx3.init()

# Vari√°veis globais para armazenar os saldos e posi√ß√µes
saldos_disponiveis = {}
posicoes_ativas = {}
saldo_inicial = None  # Vari√°vel para armazenar o saldo inicial
precos_compra = {}    # Dicion√°rio para armazenar o pre√ßo m√©dio de compra dos ativos
dados_sinais = []     # Exemplo de Uso
ultima_compra = {}    # Dicion√°rio para armazenar o timestamp da √∫ltima compra de cada ativo
ultima_atualizacao_modelo_por_ativo = {}  # Dicion√°rio para acompanhar carregamento de modelos

# Hist√≥rico de saldos por per√≠odo
historico_saldos = {
    "ano": None,
    "mes": None,
    "semana": None,
    "dia": None
}

# Registrar √∫ltima data atualizada para controle di√°rio
ultima_data_atualizada = {
    "ano": None,
    "mes": None,
    "semana": None,
    "dia": None
}

def atualizar_saldos_periodicos(saldo_atual):
    global historico_saldos, ultima_data_atualizada

    agora = datetime.now()
    ano_atual, mes_atual, semana_atual, dia_atual = agora.year, agora.month, agora.isocalendar()[1], agora.day

    if historico_saldos["ano"] is None or ultima_data_atualizada["ano"] != ano_atual:
        historico_saldos["ano"] = saldo_atual
        ultima_data_atualizada["ano"] = ano_atual

    if historico_saldos["mes"] is None or ultima_data_atualizada["mes"] != mes_atual:
        historico_saldos["mes"] = saldo_atual
        ultima_data_atualizada["mes"] = mes_atual

    if historico_saldos["semana"] is None or ultima_data_atualizada["semana"] != semana_atual:
        historico_saldos["semana"] = saldo_atual
        ultima_data_atualizada["semana"] = semana_atual

    if historico_saldos["dia"] is None or ultima_data_atualizada["dia"] != dia_atual:
        historico_saldos["dia"] = saldo_atual
        ultima_data_atualizada["dia"] = dia_atual

# ‚úÖ Recuperar entradas salvas em disco
for ativo in ativos:
    caminho_entrada = f"modelos/{ativo}_entrada.json"
    if os.path.exists(caminho_entrada):
        try:
            with open(caminho_entrada, "r") as f:
                dados = json.load(f)
                preco_entrada = dados.get("preco_compra", 0)
                if preco_entrada > 0:
                    precos_compra[ativo] = preco_entrada
        except Exception as e:
            print(f"[ERRO] Falha ao carregar entrada de {ativo}: {e}")


# == 02. Banco de Dados e Inicializa√ß√µes === #
def atualizar_modelo_se_melhor(modelo_novo, ativo, score_novo, forcar=False):
    """
    Substitui o modelo salvo apenas se o novo modelo for melhor.
    """
    caminho_modelo = f"modelos/{ativo}_modelo.pkl"
    caminho_meta = f"modelos/{ativo}_meta.json"

    if not os.path.exists(MODELO_DIR):
        os.makedirs(MODELO_DIR)

    meta_atual = {}
    if os.path.exists(caminho_meta):
        with open(caminho_meta, "r") as f:
            meta_atual = json.load(f)

    score_antigo = meta_atual.get("score", 0)
    if forcar or (score_novo > score_antigo):
        joblib.dump(modelo_novo, caminho_modelo)
        meta_atual["score"] = score_novo
        meta_atual["timestamp"] = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
        with open(caminho_meta, "w") as f:
            json.dump(meta_atual, f, indent=2)
        return True

    return False

def configurar_logging():
    """
    Configura sistema de logging padronizado para facilitar diagn√≥stico de erros.
    Cria logs separados para diferentes componentes do sistema.
    
    Retorna:
        dict: Dicion√°rio com loggers configurados para diferentes partes do sistema
    """
    import logging
    import os
    import sys
    
    # Criar diret√≥rio para logs se n√£o existir
    if not os.path.exists('logs'):
        os.makedirs('logs')
    
    # Data atual para nomes de arquivo
    data_atual = datetime.now().strftime('%Y-%m-%d')
    
    # Configurar formato comum para todas as mensagens
    formato = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # Criar diferentes loggers para componentes do sistema
    loggers = {}
    
    # 1. Logger para trading (opera√ß√µes de compra e venda)
    trading_logger = logging.getLogger('trading')
    trading_logger.setLevel(logging.INFO)
    
    # Impede que mensagens do logger 'trading' vazem para o console
    logger.propagate = False

    
    # Handler para arquivo
    trading_handler = logging.FileHandler(f'logs/trading_{data_atual}.log')
    trading_handler.setFormatter(formato)
    trading_logger.addHandler(trading_handler)
    
    # ‚ùå N√ÉO adiciona console handler
    # Apenas logs em arquivo
    # console_handler = logging.StreamHandler()
    # console_handler.setFormatter(formato)
    # trading_logger.addHandler(console_handler)

    
    loggers['trading'] = trading_logger
    
    # 2. Logger para backtesting
    backtest_logger = logging.getLogger('backtest')
    backtest_logger.setLevel(logging.INFO)
    
    backtest_handler = logging.FileHandler(f'logs/backtest_{data_atual}.log')
    backtest_handler.setFormatter(formato)
    backtest_logger.addHandler(backtest_handler)
    #backtest_logger.addHandler(console_handler)  # Reutilizar console handler
    
    loggers['backtest'] = backtest_logger
    
    # 3. Logger para erros (n√≠vel mais detalhado)
    error_logger = logging.getLogger('error')
    error_logger.setLevel(logging.DEBUG)  # Debug para capturar tudo
    
    error_handler = logging.FileHandler(f'logs/error_{data_atual}.log')
    error_handler.setFormatter(formato)
    error_logger.addHandler(error_handler)
    
    loggers['error'] = error_logger
    
    # 4. Logger para modelo (treinamento e previs√µes)
    model_logger = logging.getLogger('model')
    model_logger.setLevel(logging.INFO)
    
    model_handler = logging.FileHandler(f'logs/model_{data_atual}.log')
    model_handler.setFormatter(formato)
    model_logger.addHandler(model_handler)
    
    loggers['model'] = model_logger
    
    # Configurar exce√ß√µes n√£o capturadas para irem para o log de erros
    def handler_excecao(tipo, valor, traceback):
        error_logger.critical("Exce√ß√£o n√£o capturada:", exc_info=(tipo, valor, traceback))
        # Mostrar tamb√©m no stderr padr√£o
        sys.__excepthook__(tipo, valor, traceback)
    
    # Substituir o handler de exce√ß√µes padr√£o
    sys.excepthook = handler_excecao
    
    # Fun√ß√£o auxiliar para facilitar o logging de erros em blocos try-except
    def log_exception(e, mensagem="Erro n√£o especificado", logger_name='error'):
        import traceback
        if logger_name in loggers:
            loggers[logger_name].error(f"{mensagem}: {str(e)}")
            loggers[logger_name].debug(traceback.format_exc())
        else:
            error_logger.error(f"{mensagem}: {str(e)}")
            error_logger.debug(traceback.format_exc())
    
    # Adicionar a fun√ß√£o ao dicion√°rio de loggers
    loggers['log_exception'] = log_exception
    
    return loggers    
                    
def conectar_bd():
    return sqlite3.connect(DB_PATH)

def inicializar_bd():
    conn = conectar_bd()
    cursor = conn.cursor()

    # Tabela de opera√ß√µes (compras e vendas)
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS operacoes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        data TEXT,
        ativo TEXT,
        operacao TEXT,
        quantidade REAL,
        preco REAL,
        valor_total REAL,
        lucro_percentual REAL
    )
    """)

    # Tabela de performance dos modelos
    cursor.execute("""
    CREATE TABLE IF NOT EXISTS performance_modelos (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        data TEXT,
        ativo TEXT,
        taxa_acerto REAL,
        intervalo TEXT,
        indicadores TEXT
    )
    """)

    conn.commit()
    conn.close()

def inicializar_historico():
    """
    Inicializa o arquivo de hist√≥rico de opera√ß√µes se ele n√£o existir.
    Cria um arquivo CSV com cabe√ßalhos apropriados.
    """
    HISTORICO_ARQUIVO = "historico_operacoes.csv"  # Certifique-se de usar o mesmo nome definido em outras partes do c√≥digo
    
    import os
    import csv
    if not os.path.exists(HISTORICO_ARQUIVO):
        with open(HISTORICO_ARQUIVO, mode='w', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([
                "Data", "Ativo", "Opera√ß√£o", "Quantidade", "Pre√ßo",
                "Valor Total", "Lucro (%)", "Status"
            ])
        print(f"‚úÖ Arquivo de hist√≥rico criado: {HISTORICO_ARQUIVO}")
    else:
        print(f"‚úÖ Arquivo de hist√≥rico existente: {HISTORICO_ARQUIVO}")

def salvar_operacao(ativo, operacao, quantidade, preco, lucro_percentual=None):
    conn = conectar_bd()
    cursor = conn.cursor()

    valor_total = quantidade * preco
    data = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    cursor.execute("""
    INSERT INTO operacoes (data, ativo, operacao, quantidade, preco, valor_total, lucro_percentual)
    VALUES (?, ?, ?, ?, ?, ?, ?)
    """, (data, ativo, operacao, quantidade, preco, valor_total, lucro_percentual))

    conn.commit()
    conn.close()

def salvar_performance_modelo(ativo, taxa_acerto, intervalo, indicadores):
    """
    Registra a performance do modelo no banco de dados.
    """
    conn = conectar_bd()
    cursor = conn.cursor()

    data = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    indicadores_str = ", ".join(indicadores)

    cursor.execute("""
    INSERT INTO performance_modelos (data, ativo, taxa_acerto, intervalo, indicadores)
    VALUES (?, ?, ?, ?, ?)
    """, (data, ativo, taxa_acerto, intervalo, indicadores_str))

    conn.commit()
    conn.close()

    print(f"üìä Performance registrada: {ativo} | Taxa de Acerto: {taxa_acerto:.2f}% | Intervalo: {intervalo} | Indicadores: {indicadores}")


# === 03. Fun√ß√µes de voz e notifica√ß√£o === #
def falar(frase):
    engine.say(frase)
    engine.runAndWait()

def falar_eventos(evento, ativo=None, lucro=None):
    """
    Emite falas para eventos importantes como compra, venda, backtest e otimiza√ß√µes.
    """
    if evento == "compra":
        falar(f"Compra realizada para {ativo} com sucesso.")
    elif evento == "venda":
        falar(f"Venda realizada para {ativo}. Lucro de {lucro:.2f} por cento.")
    elif evento == "backtest":
        falar("Backtest conclu√≠do. Modelos foram atualizados.")
    elif evento == "otimizacao":
        falar("Otimiza√ß√£o realizada com sucesso. Estrat√©gias ajustadas.")


# === 04. Fun√ß√µes de saldo e posi√ß√µes === #
def ajustar_quantidade_para_lot_size(quantidade, symbol):
    """
    Ajusta a quantidade para o lote m√≠nimo permitido pela Binance.
    Retorna: (quantidade_ajustada, min_qty, min_notional).
    """
    info = client.get_symbol_info(symbol)

    if not info:
        print(f"‚ö†Ô∏è Erro: N√£o foi poss√≠vel obter as regras de lote m√≠nimo para {symbol}.")
        return 0, 0, 0

    min_qty = 0
    step_size = 0
    min_notional = 0

    for f in info["filters"]:
        if f["filterType"] == "LOT_SIZE":
            min_qty = float(f["minQty"])
            step_size = float(f["stepSize"])
        elif f["filterType"] == "MIN_NOTIONAL":
            min_notional = float(f["minNotional"])
        elif f["filterType"] == "NOTIONAL":
            min_notional = float(f.get("minNotional", 0))

    # ‚úÖ Fallback manual caso min_notional n√£o seja encontrado
    if min_notional == 0:
        print(f"‚ö†Ô∏è Nenhum min_notional encontrado para {symbol}. Usando fallback de R$10.")
        min_notional = 10

    # Garantir que quantidade √© um n√∫mero v√°lido
    try:
        quantidade = float(quantidade)
    except (ValueError, TypeError):
        print(f"‚ö†Ô∏è Quantidade inv√°lida: {quantidade}. Usando 0.")
        quantidade = 0

    # Ajustar a precis√£o com base no step_size
    if step_size > 0:
        # Determinar o n√∫mero de casas decimais com base no step_size
        precision = len(str(step_size).split('.')[-1])
        # Arredondamento para o m√∫ltiplo de step_size mais pr√≥ximo
        quantidade_ajustada = round(quantidade - (quantidade % step_size), precision)
        # Garantir que √© pelo menos o m√≠nimo
        quantidade_ajustada = max(quantidade_ajustada, min_qty)
        # Formatar com a precis√£o correta como string
        quantidade_ajustada = "{:.{}f}".format(quantidade_ajustada, precision)
        # Remover zeros √† direita e pontos desnecess√°rios
        quantidade_ajustada = quantidade_ajustada.rstrip('0').rstrip('.') if '.' in quantidade_ajustada else quantidade_ajustada
    else:
        quantidade_ajustada = str(quantidade)

    # Converter de volta para float para compara√ß√µes
    quantidade_float = float(quantidade_ajustada)
    
    # Verificar se a quantidade atende aos requisitos m√≠nimos
    if quantidade_float < min_qty:
        print(f"‚ö†Ô∏è Quantidade ajustada ({quantidade_float}) abaixo do lote m√≠nimo ({min_qty}).")
        return 0, min_qty, min_notional
    
    # Retornar a quantidade como string formatada corretamente para a API
    return quantidade_ajustada, min_qty, min_notional

def listar_saldos(modo_silencioso=False):
    """
    Obt√©m os saldos dispon√≠veis da Binance e determina a posi√ß√£o dos ativos.
    
    Par√¢metros:
    - modo_silencioso: Se True, n√£o imprime detalhes dos saldos no console
    """
    global saldos_disponiveis, posicoes_ativas

    try:
        conta = client.get_account()
        novos_saldos = {}
        novas_posicoes = {}

        if not modo_silencioso:
            print("\nüìå [DEBUG] Obtendo saldos dispon√≠veis...")

        # Obten√ß√£o dos saldos
        for item in conta["balances"]:
            ativo = item["asset"]
            saldo = float(item["free"])
            if saldo > 0:
                novos_saldos[ativo] = saldo

        saldos_disponiveis = novos_saldos.copy()

        # Impress√£o detalhada apenas se n√£o estiver em modo silencioso
        if not modo_silencioso:
            print("\n{:<6} {:>12} {:>15} {:>15}".format("Ativo", "Qty Ativo", "Lote M√≠nimo", "Posi√ß√£o"))
            print("=" * 50)

        # Processamento dos ativos
        for ativo in ativos:
            ativo_base = ativo.replace("BRL", "")
            saldo_ativo = float(saldos_disponiveis.get(ativo_base, 0))
            _, min_qty, min_notional = ajustar_quantidade_para_lot_size(saldo_ativo, ativo)

            try:
                preco_atual = float(client.get_symbol_ticker(symbol=ativo)["price"])
            except:
                preco_atual = 0  

            tem_posicao = saldo_ativo >= min_qty and (saldo_ativo * preco_atual) >= min_notional
            novas_posicoes[ativo] = tem_posicao

            # Impress√£o detalhada apenas se n√£o estiver em modo silencioso
            if not modo_silencioso:
                status_posicao = "‚úÖ SIM" if tem_posicao else "üõë N√ÉO"
                print("{:<6} {:>12.6f} {:>15.6f} {:>15}".format(
                    ativo_base, saldo_ativo, min_qty, status_posicao
                ))

        # C√°lculo de saldo e investimento
        saldo_brl = float(saldos_disponiveis.get("BRL", 0))
        ativos_sem_posicao = [a for a in ativos if not novas_posicoes[a]]
        investimento_por_ativo = saldo_brl / len(ativos_sem_posicao) if ativos_sem_posicao else 0  

        saldos_disponiveis["investimento_por_ativo"] = investimento_por_ativo
        posicoes_ativas = novas_posicoes

        # Impress√£o resumida apenas se n√£o estiver em modo silencioso
        if not modo_silencioso:
            print("\nüìå Saldo BRL: R${:.2f} | Investimento por ativo: R${:.2f}".format(
                saldo_brl, investimento_por_ativo
            ))

    except Exception as e:
        print(f"‚ùå Erro ao listar saldos: {e}")

def obter_saldo_inicial_fixo(periodo, chave, saldo_atual):
    """
    Recupera ou grava o saldo inicial fixo por per√≠odo (dia, semana, m√™s, ano).
    """
    arquivo_saldos = "saldos_iniciais.json"
    saldos = {}

    # Carrega arquivo, se existir
    if os.path.exists(arquivo_saldos):
        with open(arquivo_saldos, "r") as f:
            try:
                saldos = json.load(f)
            except:
                saldos = {}

    # Cria estrutura se necess√°rio
    if periodo not in saldos:
        saldos[periodo] = {}

    # Se j√° existe, retorna
    if chave in saldos[periodo]:
        return saldos[periodo][chave]

    # Caso contr√°rio, define e salva
    saldos[periodo][chave] = saldo_atual
    with open(arquivo_saldos, "w") as f:
        json.dump(saldos, f, indent=2)

    return saldo_atual
        
def retroalimentar_modelo(ativo):
    """
    Extrai opera√ß√µes hist√≥ricas e retroalimenta o modelo com base nas varia√ß√µes de pre√ßo.
    """
    modelo_path = f"modelos/{ativo}_modelo.pkl"
    if not os.path.exists(modelo_path):
        print(f"‚ùå Modelo n√£o encontrado para {ativo}")
        return False

    # 1. Coleta de opera√ß√µes
    try:
        conn = conectar_bd()
        cursor = conn.cursor()
        cursor.execute("""
            SELECT preco, operacao, data FROM operacoes
            WHERE ativo = ? ORDER BY data ASC
        """, (ativo,))
        dados = cursor.fetchall()
        conn.close()

        if len(dados) < 10:
            print(f"‚ö†Ô∏è Poucos dados para retroalimentar modelo de {ativo}")
            return False
    except Exception as e:
        print(f"‚ùå Erro ao acessar banco: {e}")
        return False

    # 2. Constru√ß√£o de dados supervisionados
    X_novos = []
    y_novos = []

    for i in range(1, len(dados)):
        preco_ant, _, data_ant = dados[i - 1]
        preco_atual, oper, data_atual = dados[i]

        variacao_pct = ((preco_atual - preco_ant) / preco_ant) * 100 if preco_ant > 0 else 0
        X_novos.append([variacao_pct])  # Feature: varia√ß√£o anterior
        y_novos.append(1 if preco_atual > preco_ant else 0)

    # 3. Carregamento e retrofit
    try:
        modelo = joblib.load(modelo_path)
        if hasattr(modelo, "partial_fit"):

            # Recuperar features esperadas
            features_modelo = getattr(modelo, 'feature_names_in_', None)

            # Se o modelo espera m√∫ltiplas features, n√£o aplicar retrofit com apenas uma
            if features_modelo is not None and len(features_modelo) > 1:
                print(f"‚ö†Ô∏è Modelo espera {len(features_modelo)} features. Retrofit cancelado: apenas 1 fornecida.")
                return False
            
            modelo.partial_fit(X_novos, y_novos, classes=[0, 1])
            logger.info(f"‚úÖ [RETROFIT] Modelo {ativo} atualizado com {len(X_novos)} exemplos.")
        else:
            modelo = RandomForestClassifier(n_estimators=100)
            modelo.fit(X_novos, y_novos)

        joblib.dump(modelo, modelo_path)
        print(f"‚úÖ Modelo retroalimentado e salvo ({len(X_novos)} exemplos)")
        return True
    except Exception as e:
        print(f"‚ö†Ô∏è Erro no retrofit de modelo {ativo}: {e}")
        return False

def registrar_distribuicao_features(ativo, df, caminho="distribuicoes"):
    """
    Salva a distribui√ß√£o estat√≠stica das features mais recentes para comparar deriva do modelo.
    """
    os.makedirs(caminho, exist_ok=True)
    stats_path = os.path.join(caminho, f"{ativo}_distribuicao.csv")

    try:
        estatisticas = df.describe().T[["mean", "std", "min", "max"]]
        estatisticas["data"] = datetime.now().strftime("%Y-%m-%d")
        estatisticas.to_csv(stats_path, mode='a', header=not os.path.exists(stats_path))
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao registrar distribui√ß√£o de features para {ativo}: {e}")




# === 05. Fun√ß√µes de busca de dados e carga de modelos === #
def buscar_dados_binance(ativos, tentativas_max=3, modo_silencioso=False):
    """
    Obt√©m os dados de mercado da Binance para os ativos fornecidos.
    
    Par√¢metros:
    - ativos: Lista de ativos para buscar dados
    - tentativas_max: N√∫mero m√°ximo de tentativas em caso de falha
    - modo_silencioso: Se True, reduz as mensagens de log
    
    Retorna:
    - Tupla com (dados_mercado, modelos_info) onde:
        - dados_mercado: Dicion√°rio com os dados de cada ativo
        - modelos_info: Dicion√°rio com informa√ß√µes dos modelos carregados
    """
    if not modo_silencioso:
        print(f"\nüîπ [COLETANDO DADOS DE MERCADO] üîπ {datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        
    dados_mercado = {}
    falhas = []
    
    # Dicion√°rio para armazenar informa√ß√µes dos modelos carregados
    modelos_info = {}

    for ativo in ativos:
        tentativas = tentativas_max
        df = None

        while tentativas > 0:
            try:
                klines = client.get_klines(
                    symbol=ativo,
                    interval=Client.KLINE_INTERVAL_5MINUTE,
                    limit=500
                )

                if not klines:
                    raise ValueError(f"‚ö†Ô∏è Nenhum dado retornado para {ativo}")

                df = pd.DataFrame(klines, columns=[
                    "timestamp", "open", "high", "low", "close", "volume",
                    "close_time", "quote_asset_volume", "number_of_trades",
                    "taker_buy_base", "taker_buy_quote", "ignore"
                ])

                df["timestamp"] = pd.to_datetime(df["timestamp"], unit="ms")
                df[["open", "high", "low", "close", "volume"]] = df[["open", "high", "low", "close", "volume"]].astype(float)

                # Mant√©m apenas colunas essenciais
                df = df[["timestamp", "open", "high", "low", "close", "volume"]]

                # Se as colunas essenciais existem e o DataFrame n√£o est√° vazio, interrompe o loop
                if not df.empty and all(col in df.columns for col in ["open", "high", "low", "close", "volume"]):
                    break

            except Exception as e:
                if not modo_silencioso:
                    print(f"‚ö†Ô∏è [ERRO] Falha ao obter dados para {ativo} ({tentativas} tentativas restantes): {e}")
                df = None
                tentativas -= 1
                time.sleep(2)  # Aguarda 2 segundos antes de tentar novamente

        if df is not None and not df.empty:
            if not modo_silencioso:
                print(f"‚úÖ [DEBUG] Dados obtidos para {ativo}")
            dados_mercado[ativo] = df
            
            # Carregar informa√ß√µes do modelo sem imprimir duplica√ß√µes
            try:
                _, _, _, _, intervalo, _ = carregar_modelo(ativo)
                modelos_info[ativo] = intervalo
                if not modo_silencioso:
                    print(f"‚úÖ Modelo carregado para {ativo}: {intervalo}")
            except Exception as e:
                if not modo_silencioso:
                    print(f"‚ö†Ô∏è Erro ao carregar modelo para {ativo}: {e}")
        else:
            falhas.append(ativo)

    if falhas and not modo_silencioso:
        print(f"‚ö†Ô∏è Falha na busca de dados para: {', '.join(falhas)}")

    return dados_mercado, modelos_info

def obter_intervalo_modelo(ativo):
    """
    Fun√ß√£o simplificada que apenas retorna o intervalo do modelo,
    sem carregar o modelo completo para evitar prints desnecess√°rios.
    """
    caminho_meta = f"modelos/{ativo}_meta.json"

    intervalo = "5m"  # valor padr√£o

    if os.path.exists(caminho_meta):
        try:
            with open(caminho_meta, "r") as f:
                meta = json.load(f)
                intervalo = meta.get("intervalo", "5m")
        except Exception:
            pass
    
    return intervalo

def obter_saldo_inicial(lista_saldo):
    """
    Retorna o saldo inicial do dia baseado na lista de saldo da corretora.
    O saldo inicial √© armazenado apenas na primeira execu√ß√£o.
    """
    global saldo_inicial

    if saldo_inicial is None:
        saldo_inicial = lista_saldo.get("BRL", 0)  # Obt√©m o saldo em BRL na primeira execu√ß√£o

    return saldo_inicial

def obter_saldo_atual(lista_saldo):
    """
    Retorna o saldo atual dispon√≠vel em BRL, baseado na lista de saldo da corretora.
    Se n√£o houver saldo registrado, retorna 0.
    """
    return lista_saldo.get("BRL", 0)  # Obt√©m o saldo em BRL ou retorna 0 se n√£o existir

def carregar_modelo(ativo):
    """
    Carrega o modelo salvo, junto com suas informa√ß√µes principais.
    Lida com arquivos potencialmente corrompidos.

    Retorna:
      (modelo, scaler, meta_info, indicadores, intervalo)
    """
    import os
    import joblib
    import json

    caminho_modelo = f"modelos/{ativo}_modelo.pkl"
    caminho_meta = f"modelos/{ativo}_meta.json"
    caminho_scaler = f"modelos/{ativo}_scaler.pkl"

    modelo, scaler, meta_info, indicadores = None, None, {}, []
    intervalo = "5m"

    if os.path.exists(caminho_modelo) and os.path.exists(caminho_meta):
        try:
            # Verificar tamanho do arquivo - arquivos muito pequenos provavelmente est√£o corrompidos
            tamanho_arquivo = os.path.getsize(caminho_modelo)
            if tamanho_arquivo < 100:  # Tamanho m√≠nimo razo√°vel para um modelo serializado
                print(f"‚ö†Ô∏è Arquivo de modelo para {ativo} parece estar corrompido (tamanho: {tamanho_arquivo} bytes)")
                
                # Renomear arquivo corrompido
                try:
                    backup_path = f"{caminho_modelo}.corrupted"
                    os.rename(caminho_modelo, backup_path)
                    print(f"üîÑ Arquivo corrompido movido para {backup_path}")
                except Exception as rename_err:
                    print(f"‚ö†Ô∏è N√£o foi poss√≠vel renomear arquivo corrompido: {rename_err}")
                
                return None, None, {}, [], intervalo
            
            modelo = joblib.load(caminho_modelo)

            if hasattr(modelo, 'feature_names_in_'):
                pass  # j√° definido
            elif "indicadores" in meta_info:
                modelo.feature_names_in_ = np.array(meta_info["indicadores"])
            else:
                print(f"‚ö†Ô∏è Modelo {ativo} sem feature_names_in_ nem indicadores salvos.")
            
            # === Valida√ß√£o do Scaler ===
            # Carregar meta antes de validar scaler
            with open(caminho_meta, "r", encoding='utf-8') as f:
                meta_info = json.load(f)
            indicadores = meta_info.get("indicadores", [])
            intervalo = meta_info.get("intervalo", "5m")
            regime = meta_info.get("regime", "DESCONHECIDO")

            # === Valida√ß√£o do Scaler ===
            if os.path.exists(caminho_scaler):
                try:
                    scaler = joblib.load(caminho_scaler)
                    if hasattr(scaler, "n_features_in_") and len(indicadores) != scaler.n_features_in_:
                        print(f"‚ö†Ô∏è Scaler incompat√≠vel: esperado {scaler.n_features_in_}, atual {len(indicadores)}")
                        scaler = None
                    elif hasattr(scaler, "transform"):
                        teste = np.array([[0.1]*len(indicadores)]).astype(float)
                        _ = scaler.transform(teste)
                    else:
                        raise ValueError("Scaler inv√°lido ou n√£o possui m√©todo transform.")

                except Exception as e:
                    print(f"‚ö†Ô∏è Erro de integridade no scaler de {ativo}: {e}")
                    scaler = None
            else:
                print(f"‚ö†Ô∏è Scaler ausente para {ativo}")
                scaler = None
            
            with open(caminho_meta, "r", encoding='utf-8') as f:
                meta_info = json.load(f)
            
            indicadores = meta_info.get("indicadores", [])
            intervalo = meta_info.get("intervalo", "5m")
            regime = meta_info.get("regime", "DESCONHECIDO")

            # Garante que regime nunca seja vazio
            if not regime or regime.strip() == "":
                regime = "DESCONHECIDO"
            
            # Exemplo de notifica√ß√£o para telegram/log se for a 1¬™ vez em 4h
            global ultima_atualizacao_modelo_por_ativo
            timestamp_atual = datetime.now()
            if 'ultima_atualizacao_modelo_por_ativo' not in globals():
                ultima_atualizacao_modelo_por_ativo = {}
            
            if (ativo not in ultima_atualizacao_modelo_por_ativo or 
                (timestamp_atual - ultima_atualizacao_modelo_por_ativo[ativo]).total_seconds() > 14400):
                # notificar_modelo_carregado(ativo, intervalo, meta_info.get("score", 0.0), indicadores)
                ultima_atualizacao_modelo_por_ativo[ativo] = timestamp_atual
            
            return modelo, scaler, meta_info, indicadores, intervalo, regime

        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao carregar modelo para {ativo}: {e}")
            
            # Se o arquivo existe mas n√£o p√¥de ser carregado, ele pode estar corrompido
            # Vamos renome√°-lo para for√ßar um novo treinamento
            try:
                # Renomear para backup em vez de excluir
                backup_path = f"{caminho_modelo}.corrupted"
                os.rename(caminho_modelo, backup_path)
                print(f"üîÑ Arquivo corrompido movido para {backup_path}")
            except Exception as rename_err:
                print(f"‚ö†Ô∏è N√£o foi poss√≠vel renomear arquivo corrompido: {rename_err}")
                
            return None, None, {}, [], intervalo
    else:
        # print(f"‚ö†Ô∏è Nenhum modelo encontrado para {ativo}.")
        return None, None, {}, [], intervalo

def registrar_operacao(ativo, operacao, quantidade, preco, preco_compra=None, razoes=None):
    """
    Registra a opera√ß√£o de compra ou venda no hist√≥rico, no banco de dados e envia mensagem ao Telegram.
    Inclui explica√ß√µes detalhadas sobre as raz√µes da opera√ß√£o.
    """
    global precos_compra

    valor_total = quantidade * preco
    lucro_percentual = 0.0
    lucro_real = 0.0
    taxa_sucesso = False  # Define se a opera√ß√£o teve sucesso ou n√£o

    # Se for VENDA, calcula lucro/preju√≠zo
    if operacao == "VENDA" and preco_compra:
        if preco_compra > 0:
            lucro_percentual = ((preco - preco_compra) / preco_compra) * 100
            lucro_real = (preco - preco_compra) * quantidade
            taxa_sucesso = lucro_percentual > 0.2  # Considera sucesso se lucro > 0,2%

    # Indicadores leg√≠veis
    status_texto = "SUCESSO" if taxa_sucesso else "FALHA"
            
    # Gravar no arquivo de hist√≥rico CSV
    try:
        with open(HISTORICO_ARQUIVO, mode='a', newline='') as file:
            writer = csv.writer(file)
            writer.writerow([
                datetime.now().strftime("%Y-%m-%d %H:%M:%S"), ativo, operacao, quantidade, preco,
                valor_total, round(lucro_percentual, 2) if isinstance(lucro_percentual, float) else lucro_percentual,
                status_texto,
                "NAO"  # <-- Aprendido: "NAO" por padr√£o
            ])

    except Exception as e:
        print(f"[X] Erro ao gravar no hist√≥rico CSV: {e}")

    # Gravar no banco de dados
    try:
        salvar_operacao(ativo, operacao, quantidade, preco, 
                        float(lucro_percentual) if isinstance(lucro_percentual, float) else None)
    except Exception as e:
        print(f"[X] Erro ao salvar no banco de dados: {e}")

    # Log no terminal
    print(f"[INFO] Opera√ß√£o registrada: {operacao} {ativo} | Qtde: {quantidade} | Pre√ßo: R${preco:.2f} | Lucro: {lucro_percentual:.2f}% | Status: {status_texto}")

    # Enviar mensagem ao Telegram com formato padronizado e melhorado
    try:
        _, _, _, _, intervalo, _ = carregar_modelo(ativo)
        
        # Formatar raz√µes para melhor visualiza√ß√£o se existirem
        razoes_formatadas = ""
        if razoes:
            # Verifica se j√° est√° formatado como t√≥picos
            if "‚Ä¢ " in razoes:
                razoes_formatadas = f"\n{razoes}"
            else:
                # Tenta dividir em linhas se houver separadores comuns
                itens = []
                if ", " in razoes:
                    itens = razoes.split(", ")
                elif " | " in razoes:
                    itens = razoes.split(" | ")
                else:
                    itens = [razoes]  # Mant√©m como um √∫nico item
                
                # Formata como t√≥picos
                razoes_formatadas = "\n‚Ä¢ " + "\n‚Ä¢ ".join(itens)
        
        # Formata emojis indicadores de estado
        if operacao == "COMPRA":
            emoji_operacao = "üü¢"
            status_emoji = "üíµ"
        else:  # VENDA
            emoji_operacao = "üî¥"
            if lucro_percentual > 0:
                status_emoji = "üí∞"  # Lucro
            else:
                status_emoji = "üìâ"  # Preju√≠zo
        
        if operacao == "COMPRA":
            mensagem = f"""
{emoji_operacao} *COMPRA REALIZADA* {status_emoji}
------------------------------------------
üîπ *Ativo:* {ativo}
üîπ *Quantidade:* {quantidade:.6f}
üîπ *Pre√ßo de Compra:* R$ {preco:.2f}
üîπ *Intervalo:* {intervalo}

üìä *RAZ√ïES DA OPERA√á√ÉO:* {razoes_formatadas}
"""
        else:  # VENDA
            # Determina emoji de lucro/preju√≠zo
            if lucro_percentual > 3:
                emoji_lucro = "ü§ë"  # Lucro excelente
            elif lucro_percentual > 0:
                emoji_lucro = "üí∞"  # Lucro positivo
            elif lucro_percentual > -3:
                emoji_lucro = "‚ö†Ô∏è"  # Pequeno preju√≠zo
            else:
                emoji_lucro = "üìâ"  # Preju√≠zo significativo
            
            preco_compra_formatado = preco_compra if preco_compra and preco_compra > 0 else 0
            mensagem = f"""
{emoji_operacao} *VENDA REALIZADA* {status_emoji}
------------------------------------------
üîπ *Ativo:* {ativo}
üîπ *Quantidade:* {quantidade:.6f}
üîπ *Pre√ßo de Venda:* R$ {preco:.2f}
üîπ *Pre√ßo de Compra:* R$ {preco_compra_formatado:.2f}
üîπ *Lucro:* {lucro_percentual:.2f}% {emoji_lucro}
üîπ *Lucro Real:* R$ {lucro_real:.2f}
üîπ *Status:* {status_texto}

üìä *RAZ√ïES DA OPERA√á√ÉO:* {razoes_formatadas}
"""
        
        # Enviar a mensagem padronizada ao Telegram
        enviar_mensagem_telegram(mensagem)
    except Exception as e:
        print(f"[X] Erro ao enviar notifica√ß√£o ao Telegram: {e}")

    # Atualiza ou remove o pre√ßo de compra
    if operacao == "COMPRA":
        precos_compra[ativo] = preco

        # ‚úÖ Salvar entrada em arquivo
        with open(f"modelos/{ativo}_entrada.json", "w") as f:
            json.dump({
                "ativo": ativo,
                "preco_compra": preco,
                "data": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
            }, f)

    elif operacao == "VENDA":
        precos_compra.pop(ativo, None)

        # ‚úÖ Apagar o arquivo de entrada salvo
        caminho = f"modelos/{ativo}_entrada.json"
        if os.path.exists(caminho):
            os.remove(caminho)
            
        # ‚úÖ Retrofit do modelo ap√≥s venda
        try:
            resultado_retrofit = retroalimentar_modelo(ativo)
            if resultado_retrofit:
                print(f"üîÅ Modelo de {ativo} retroalimentado ap√≥s venda.")
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao retroalimentar modelo de {ativo} ap√≥s venda: {e}")

def retroalimentar_com_csv(ativo):
    """
    Treina o modelo usando opera√ß√µes anteriores marcadas como 'NAO' no campo Aprendido
    """
    import pandas as pd

    if not os.path.exists(HISTORICO_ARQUIVO):
        print(f"üìÅ Hist√≥rico {HISTORICO_ARQUIVO} n√£o encontrado.")
        return

    try:
        # ‚úÖ Valida√ß√£o de colunas antes de processar
        with open(HISTORICO_ARQUIVO, 'r') as f:
            header = f.readline().strip().split(',')
            if len(header) < 8:
                print(f"‚ùå CSV com estrutura inv√°lida. Esperado >=8 colunas, recebido: {len(header)}")
                return

        # ‚úÖ Leitura robusta com tratamento de linhas corrompidas
        df = pd.read_csv(HISTORICO_ARQUIVO, on_bad_lines='skip', engine='python')

        # Valida√ß√£o das colunas essenciais
        colunas_esperadas = ["Ativo", "Opera√ß√£o", "Quantidade", "Pre√ßo", "Lucro (%)", "Aprendido"]
        for col in colunas_esperadas:
            if col not in df.columns:
                print(f"‚ùå Coluna ausente no CSV: {col}")
                return

        if "Ativo" not in df.columns:
            print("‚ùå Coluna ausente no CSV: Ativo")
            return

        df_ativo = df[(df["Ativo"] == ativo) & (df["Aprendido"] != "SIM")]


        if df_ativo.empty:
            print(f"‚ÑπÔ∏è Nenhum dado novo para retroalimentar modelo de {ativo}")
            return

        # Define X_novos e y_novos com base na opera√ß√£o
        df_ativo = df_ativo[df_ativo["Opera√ß√£o"].isin(["COMPRA", "VENDA"])]
        df_ativo["target"] = df_ativo["Opera√ß√£o"].apply(lambda x: 1 if x == "COMPRA" else 0)

        # Usar features simplificadas ‚Äî para testar funcionamento
        regimes = df_ativo.get("Regime", "NEUTRO").fillna("NEUTRO").apply(lambda x: {"TEND√äNCIA": 1, "LATERAL": 0, "NEUTRO": -1}.get(x, -1))
        X_novos = df_ativo[["Pre√ßo", "Lucro (%)"]].copy()
        X_novos["Regime"] = regimes
        X_novos = X_novos.fillna(0)
        y_novos = df_ativo["target"]

        sucesso = retroalimentar_modelo(ativo, X_novos, y_novos)

        if sucesso:
            df.loc[df_ativo.index, "Aprendido"] = "SIM"
            df.to_csv(HISTORICO_ARQUIVO, index=False)
            print(f"‚úÖ Aprendizado retroativo aplicado para {ativo}")
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao retroalimentar {ativo} com CSV: {e}")


# Vari√°vel global para armazenar ordens pendentes
global ordens_pendentes
if 'ordens_pendentes' not in globals():
    ordens_pendentes = {}  # Inicializa caso n√£o exista

# Dicion√°rio para registrar a √∫ltima opera√ß√£o de cada ativo
ultima_operacao_tempo = {}  # Armazena o timestamp da √∫ltima opera√ß√£o
tempo_minimo_entre_operacoes = {}  # Armazena o tempo m√≠nimo entre opera√ß√µes para cada ativo



# === 06. Fun√ß√µes de logica de trading === #
def executar_ordens(dados_sinais):
    """
    Executa ordens de compra e venda com controle de tempo entre opera√ß√µes e
    inclui as raz√µes nos registros de opera√ß√£o.
    """
    listar_saldos(modo_silencioso=True)
    tempo_atual = datetime.now()
    
    for ativo, posicao, indicadores, sinal, regime, razoes in dados_sinais:
        
        # === Carrega modelo e scaler para o ativo ===
        caminho_modelo = f"modelos/{ativo}_modelo.pkl"
        caminho_scaler = f"modelos/{ativo}_scaler.pkl"

        try:
            modelo = joblib.load(caminho_modelo)
        except Exception as e:
            print(f"‚ùå Erro ao carregar modelo de {ativo}: {e}")
            continue

        try:
            scaler = joblib.load(caminho_scaler)
        except FileNotFoundError:
            scaler = None
            print(f"‚ö†Ô∏è Scaler ausente para {ativo}")
        
        try:
            # Verificar tempo desde a √∫ltima opera√ß√£o
            intervalo_modelo = modelos_info.get(ativo, "15m")  # Obt√©m o intervalo do modelo
            tempo_minimo = tempo_minimo_entre_operacoes.get(ativo, calcular_tempo_espera(intervalo_modelo))
            
            # Se n√£o tiver registro anterior, registre o intervalo m√≠nimo para este ativo
            if ativo not in tempo_minimo_entre_operacoes:
                tempo_minimo_entre_operacoes[ativo] = calcular_tempo_espera(intervalo_modelo)
                print(f"[INFO] Tempo m√≠nimo entre opera√ß√µes para {ativo}: {tempo_minimo_entre_operacoes[ativo]//60} minutos")
            
            # Verifica se j√° se passou tempo suficiente desde a √∫ltima opera√ß√£o
            if ativo in ultima_operacao_tempo:
                tempo_passado = (tempo_atual - ultima_operacao_tempo[ativo]).total_seconds()
                if tempo_passado < tempo_minimo:
                    tempo_restante = (tempo_minimo - tempo_passado) // 60
                    print(f"[INFO] Aguardando tempo m√≠nimo para {ativo}. Faltam {tempo_restante} minutos.")
                    continue  # Pula para o pr√≥ximo ativo
            
            preco_atual = float(client.get_symbol_ticker(symbol=ativo)["price"])
            saldo_brl = saldos_disponiveis.get("BRL", 0)
            ativo_base = ativo.replace("BRL", "")
            quantidade_ativo = saldos_disponiveis.get(ativo_base, 0)

            # Sanitizar strings com emojis para evitar problemas de codifica√ß√£o
            sinal_texto = "COMPRA" if "COMPRA" in sinal else "VENDA" if "VENDA" in sinal else "NEUTRO"

            # üîç Extra√ß√£o da confian√ßa a partir da raz√£o textual (se dispon√≠vel)
            conf_match = re.search(r'Conf(?:ian√ßa)?:\s*([\d.]+)%', razoes)
            confianca = float(conf_match.group(1)) if conf_match else 0

            # ‚ö†Ô∏è Pular se confian√ßa for baixa
            if confianca < 55:
                print(f"[IGNORADO] {ativo}: Confian√ßa {confianca:.1f}% insuficiente para a√ß√£o ({sinal_texto})")
                continue
                
                if sinal_texto == "COMPRA" and not posicoes_ativas.get(ativo, False):
                    investimento = saldos_disponiveis.get("investimento_por_ativo", 0)
                    print(f"[RAZ√ÉO DA COMPRA] {ativo}: {razoes}")
                    if investimento > 0:
                        quantidade = investimento / preco_atual
                        quantidade_ajustada, min_qty, min_notional = ajustar_quantidade_para_lot_size(quantidade, ativo)
                        
                        # Valor para verifica√ß√£o (agora quantidade_ajustada √© string)
                        quantidade_float = float(quantidade_ajustada) if isinstance(quantidade_ajustada, str) else quantidade_ajustada
                        
                        if quantidade_float * preco_atual >= min_notional:
                            print(f"[DEBUG] Enviando ordem de compra para {ativo}: quantidade={quantidade_ajustada}, tipo={type(quantidade_ajustada)}")
                            ordem = client.order_market_buy(symbol=ativo, quantity=quantidade_ajustada)
                            
                            # Adicionar raz√µes ao registro da opera√ß√£o
                            registrar_operacao(ativo, "COMPRA", quantidade_float, preco_atual, None, razoes)
                            
                            precos_compra[ativo] = preco_atual
                            posicoes_ativas[ativo] = True
                            falar_eventos("compra", ativo)
                            
                            # Atualizar o tempo da √∫ltima opera√ß√£o
                            ultima_operacao_tempo[ativo] = tempo_atual
                            
                            # Apenas log no console
                            print(f"[COMPRA] {ativo}: {quantidade_float:.6f} @ R${preco_atual:.2f}")

            elif sinal_texto == "VENDA" and posicoes_ativas.get(ativo, False):
                quantidade_ajustada, min_qty, min_notional = ajustar_quantidade_para_lot_size(quantidade_ativo, ativo)
                print(f"[RAZ√ÉO DA VENDA] {ativo}: {razoes}")
                
                # Valor para verifica√ß√£o e logs (agora quantidade_ajustada √© string)
                quantidade_float = float(quantidade_ajustada) if isinstance(quantidade_ajustada, str) else quantidade_ajustada
                
                if quantidade_float > 0:
                    print(f"[DEBUG] Enviando ordem de venda para {ativo}: quantidade={quantidade_ajustada}, tipo={type(quantidade_ajustada)}")
                    ordem = client.order_market_sell(symbol=ativo, quantity=quantidade_ajustada)
                    preco_compra = precos_compra.get(ativo, 0)
                    
                    # Depois da execu√ß√£o, registrar a opera√ß√£o COM RAZ√ïES
                    try:
                        registrar_operacao(ativo, "VENDA", quantidade_float, preco_atual, preco_compra, razoes)
                    except Exception as e:
                        print(f"[X] Erro ao registrar opera√ß√£o: {e}")
                        
                    lucro = ((preco_atual - preco_compra) / preco_compra) * 100 if preco_compra > 0 else 0
                    
                    try:
                        falar_eventos("venda", ativo, lucro)
                    except Exception as e:
                        print(f"[X] Erro ao notificar venda via voz: {e}")
                        
                    print(f"[VENDA] {ativo}: {quantidade_float:.6f} @ R${preco_atual:.2f} | Lucro: {lucro:.2f}%")
                    
                    posicoes_ativas[ativo] = False
                    
                    # Atualizar o tempo da √∫ltima opera√ß√£o
                    ultima_operacao_tempo[ativo] = tempo_atual

        except Exception as e:
            print(f"[X] Erro ao executar ordem para {ativo}: {e}")
            import traceback
            print(traceback.format_exc())
   
def garantir_colunas_previsao(X, modelo_features, silencioso=True):
    """
    Ajusta o DataFrame de entrada para corresponder exatamente 
    √†s features do modelo treinado, aplicando normaliza√ß√£o de dados an√¥malos.

    Par√¢metros:
    - X: DataFrame de entrada para previs√£o
    - modelo_features: Lista de features usadas no treinamento do modelo
    - silencioso: Se True, suprime mensagens de aviso

    Retorna:
    - DataFrame ajustado e sanitizado
    """
    X_ajustado = X.copy()

    # Preencher colunas ausentes
    for coluna in modelo_features:
        if coluna not in X_ajustado.columns:
            X_ajustado[coluna] = 0.0
            if not silencioso:
                print(f"[SANITIZA√á√ÉO] Coluna ausente adicionada: {coluna}")

    # Remover colunas extras
    colunas_validas = [col for col in modelo_features]
    X_ajustado = X_ajustado[modelo_features]

    # Normaliza√ß√£o: for√ßar tipo float e eliminar NaN/inf
    X_ajustado = X_ajustado.apply(pd.to_numeric, errors='coerce').replace([np.inf, -np.inf], 0).fillna(0.0)

    return X_ajustado

def gerar_sinal_consolidado(df, ativo):
    """
    Gera um sinal de trading consolidado para um ativo,
    com explica√ß√£o detalhada das raz√µes.
    
    Retorna:
        tuple: (sinal, regime, razoes)
            - sinal: "üü¢ COMPRA", "üî¥ VENDA", "‚ö™ NEUTRO"
            - regime: "TEND√äNCIA", "LATERAL", "NEUTRO", "ALTA_VOL"
            - razoes: texto explicativo
    """

    if df is None or df.empty or len(df) < 5:
        return "‚ö™ NEUTRO", "DESCONHECIDO", "Dados insuficientes"

    resultado_modelo = carregar_modelo(ativo)
    if resultado_modelo and len(resultado_modelo) == 6:
        modelo, scaler, meta_info, indicadores, intervalo, regime = resultado_modelo
    else:
        return "‚ö™ NEUTRO", "DESCONHECIDO", "Erro ao carregar modelo"

    if modelo is None:
        return "‚ö™ NEUTRO", "DESCONHECIDO", "Modelo ausente"

    explicacao = [f"üìä Estrat√©gia: Padr√£o ({intervalo})"]

    # Indicadores cl√°ssicos
    if "EMA_9" in df.columns and "EMA_21" in df.columns:
        ema9 = df["EMA_9"].iloc[-1]
        ema21 = df["EMA_21"].iloc[-1]
        diff_pct = ((ema9 - ema21) / abs(ema21)) * 100 if ema21 != 0 else 0
        direcao = "üìà" if ema9 > ema21 else "üìâ"
        explicacao.append(f"üìà EMA9/21: {diff_pct:.2f}% {direcao}")

    if "RSI" in df.columns:
        rsi = df["RSI"].iloc[-1]
        if rsi < 30:
            status = "üîπ Sobrevendido"
        elif rsi > 70:
            status = "‚ö†Ô∏è Sobrecomprado"
        else:
            status = "Neutro"
        explicacao.append(f"üîÜ RSI: {rsi:.1f} ({status})")

    if "MACD" in df.columns:
        macd = df["MACD"].iloc[-1]
        macd_prev = df["MACD"].iloc[-2] if len(df) > 1 else 0
        cruzamento = ""
        if macd > 0 and macd_prev <= 0:
            cruzamento = "‚úÖ Cruzamento positivo"
        elif macd < 0 and macd_prev >= 0:
            cruzamento = "‚ùå Cruzamento negativo"
        explicacao.append(f"üìä MACD: {macd:.2f} {cruzamento}")

    # Regime
    regime_mercado = determinar_regime_mercado(df)
    if "ADX" in df.columns:
        adx = df["ADX"].iloc[-1]
        if adx > 35:
            intensidade = "üöÄ tend√™ncia muito forte"
        elif adx > 25:
            intensidade = "üìà tend√™ncia forte"
        elif adx < 20:
            intensidade = "‚ÜîÔ∏è lateral"
        else:
            intensidade = "üìä fraca"
        explicacao.append(f"üß≠ ADX: {adx:.1f} ({intensidade})")

    try:
        X = df.drop(columns=["timestamp", "target", "Regime"], errors="ignore").copy()
        modelo_features = modelo.feature_names_in_.tolist() if hasattr(modelo, 'feature_names_in_') else indicadores
        X_proc = garantir_colunas_previsao(X.tail(1), modelo_features, silencioso=True)

        # Executar pipeline com valida√ß√£o exata
        sinal, confianca = executar_pipeline_modelo(
            modelo, scaler, X_proc, modelo_features, min_confianca=0.55
        )

        explicacao.append(f"üéØ Confian√ßa: {confianca:.1%}")
        if "NEUTRO" in sinal:
            explicacao.append(f"‚ÑπÔ∏è Confian√ßa insuficiente ({confianca:.1%}) para opera√ß√£o")

    except Exception as e:
        print(f"[ERRO previs√£o {ativo}] {e}")
        sinal = "‚ö™ NEUTRO"
        explicacao.append("‚ö†Ô∏è Erro na previs√£o")

    razoes = " | ".join(explicacao)
    return sinal, regime_mercado, razoes


def log_exception(e, mensagem="Erro", logger=None):
    """Simplifica o log de exce√ß√µes para evitar stacktraces enormes"""
    error_msg = f"{mensagem}: {str(e)}"
    if logger:
        logger.error(error_msg)
    else:
        print(f"‚ùå {error_msg}")

# === 07. Fluxo Principal de Execu√ß√£o (Loop/ciclos) === #
def calcular_tempo_espera(intervalo):
    """
    Calcula quanto tempo deve-se esperar entre opera√ß√µes com base
    no intervalo do modelo.
    
    Par√¢metros:
    - intervalo: string com o intervalo (ex: "1h", "4h", "15m")
    
    Retorna:
    - Tempo m√≠nimo em segundos
    """
    # Define valores padr√£o em minutos
    if not intervalo or intervalo == "N/A":
        return 30 * 60  # 30 minutos por padr√£o
    
    try:
        if "m" in intervalo:
            minutos = int(intervalo.replace("m", ""))
            return max(minutos * 60 * 0.25, 5 * 60)  # No m√≠nimo 25% do intervalo, mas pelo menos 5 minutos
        elif "h" in intervalo:
            horas = int(intervalo.replace("h", ""))
            return max(horas * 60 * 60 * 0.25, 15 * 60)  # No m√≠nimo 25% do intervalo, mas pelo menos 15 minutos
        else:
            return 30 * 60  # 30 minutos padr√£o
    except:
        return 30 * 60  # 30 minutos padr√£o

def carregar_modelo_indicadores(ativo):
    """
    Carrega os indicadores mais eficientes para o ativo com base no modelo salvo.
    """
    caminho_acerto = f"{MODELO_DIR}/{ativo}_taxa_acerto.json"
    if os.path.exists(caminho_acerto):
        with open(caminho_acerto, "r") as f:
            dados = json.load(f)
            return dados.get("indicadores", [])
    return []
           
def determinar_regime_mercado(df):
    """
    Determina se o mercado est√° em tend√™ncia ou lateraliza√ß√£o com base no ADX.
    Retorna um dos seguintes valores: "TEND√äNCIA", "LATERAL" ou "NEUTRO".
    """
    # Verifica se o DataFrame e a coluna ADX s√£o v√°lidos
    if df is None or df.empty or "ADX" not in df.columns or df["ADX"].isnull().all():
        return "LATERAL"
    
    try:
        # Obter o √∫ltimo valor de ADX
        adx_valor = df["ADX"].iloc[-1]
        
        # Verificar se √© um valor num√©rico v√°lido
        if pd.isna(adx_valor) or not np.isfinite(adx_valor):
            return "LATERAL"
            
        # Converter para float se for string
        if isinstance(adx_valor, str):
            try:
                adx_valor = float(adx_valor)
            except (ValueError, TypeError):
                return "LATERAL"
        
        # Aplicar regras de classifica√ß√£o
        if adx_valor >= 25:
            return "TEND√äNCIA"
        elif adx_valor <= 20:
            return "LATERAL"
        else:
            return "NEUTRO"
            
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao determinar regime de mercado: {e}")
        return "LATERAL"
     
def exibir_indicadores_detalhados(df, ativo, intervalo=None):
    """
    Exibe os valores calculados dos indicadores e suas interpreta√ß√µes.
    Se um intervalo for fornecido, ele ser√° exibido na sa√≠da.
    """
    indicadores_ativos = carregar_modelo_indicadores(ativo)

    if df is None or df.empty or len(df) < 30:
        print(f"‚ö†Ô∏è Poucos dados para calcular indicadores de {ativo}. Necess√°rio pelo menos 30 candles.")
        return

    regime_mercado = determinar_regime_mercado(df)

    print("\n" + "=" * 90)
    print(f"{ativo} - Intervalo: {intervalo if intervalo else 'Desconhecido'} | Regime: {regime_mercado}")
    print("-" * 90)
    print("{:<20} | {:<15} | {}".format("Indicador", "Valor Calculado", "Interpreta√ß√£o"))
    print("-" * 90)

    for indicador in indicadores_ativos:
        valor = df[indicador].iloc[-1] if indicador in df.columns else "N/A"
        if isinstance(valor, (int, float)) and np.isnan(valor):
            valor = "N/A"

        interpretacao = ""
        if indicador == "EMA_9" and "EMA_21" in df.columns:
            interpretacao = "üîº Alta" if df["EMA_9"].iloc[-1] > df["EMA_21"].iloc[-1] else "üîΩ Baixa"
        if indicador == "RSI":
            if isinstance(valor, (int, float)):
                interpretacao = "üü¢ Sobrevendido (< 30)" if valor < 30 else "üî¥ Sobrecomprado (> 70)" if valor > 70 else ""
        if indicador == "OBV":
            interpretacao = "üìà Alta" if df["OBV"].diff().iloc[-1] > 0 else "üìâ Baixa"
        if indicador == "ADX":
            interpretacao = "üìà Forte tend√™ncia" if valor > 25 else "üìä Mercado lateral"

        print("{:<20} | {:<15} | {}".format(indicador, round(valor, 2) if isinstance(valor, (int, float)) else valor, interpretacao))

    print("-" * 90)
    print("=" * 90)

ultimo_relatorio = None  # Inicializa a vari√°vel para evitar NameError

def exibir_sinais(dados_sinais):
    """
    Exibe a tabela de sinais consolidados com formata√ß√£o otimizada
    baseada em larguras fixas de colunas.
    """
    print("\nüöÄ [SINAIS CONSOLIDADOS] üöÄ")
    
    # Preparar dados para tabela
    tabela = []
    LARGURA_MAX_INDICADORES = 25  # Define tamanho m√°ximo para coluna de indicadores
    
    for ativo, posicao, indicadores_texto, sinal, regime in dados_sinais:
        # Obter info do modelo
        _, _, _, _, intervalo, _ = carregar_modelo(ativo)
        
        # Processar indicadores - truncar se necess√°rio
        if isinstance(indicadores_texto, str):
            ind_texto = indicadores_texto
        elif isinstance(indicadores_texto, list):
            ind_texto = ", ".join(indicadores_texto)
        else:
            ind_texto = ""
            
        # Truncar indicadores se excederem o tamanho m√°ximo
        if len(ind_texto) > LARGURA_MAX_INDICADORES:
            ind_texto = ind_texto[:LARGURA_MAX_INDICADORES-3] + "..."
        
        # Calcular lucro
        preco_compra = precos_compra.get(ativo, 0)
        try:
            preco_atual = float(client.get_symbol_ticker(symbol=ativo)["price"])
            lucro_percentual = ((preco_atual - preco_compra) / preco_compra) * 100 if preco_compra > 0 else 0
            lucro_real = (preco_atual - preco_compra) * float(saldos_disponiveis.get(ativo.replace("BRL", ""), 0))
        except:
            lucro_percentual = 0
            lucro_real = 0
        
        # Garantir regime limpo (sem espa√ßos extras)
        regime_limpo = regime.strip() if isinstance(regime, str) else "NEUTRO"
        
        # Adicionar linha √† tabela
        tabela.append([
            ativo,
            posicao,
            intervalo,
            ind_texto,
            sinal,
            regime_limpo,
            f"{lucro_percentual:.2f}",  # Formatado como string para controle preciso
            f"R$ {lucro_real:.2f}"
        ])
    
    # Definir cabe√ßalhos
    headers = ["ATIVO", "POSI√á√ÉO", "INTERVALO", "INDICADORES", "SINAL", "REGIME", "LUCRO (%)", "LUCRO (R$)"]
    
    # Definir alinhamento espec√≠fico para cada coluna
    alinhamentos = ['center', 'center', 'center', 'left', 'center', 'center', 'right', 'right']
    
    # Usar tabulate com configura√ß√µes espec√≠ficas
    from tabulate import tabulate
    tabela_formatada = tabulate(
        tabela,
        headers=headers,
        tablefmt='simple',
        colalign=alinhamentos,
        stralign='center',
        numalign='right'
    )
    
    # Personaliza√ß√£o adicional - substituir caracteres de linha para melhor apar√™ncia
    tabela_formatada = tabela_formatada.replace('-', '‚ïê')
    tabela_formatada = tabela_formatada.replace('+', '‚ï¨')
    
    # Imprimir tabela
    print(tabela_formatada)
    
    # Mostrar informa√ß√µes de saldo
    saldo_brl = saldos_disponiveis.get("BRL", 0)
    investimento_por_ativo = saldos_disponiveis.get("investimento_por_ativo", 0)
    print(f"\nüí∞ Saldo BRL: R${saldo_brl:.2f} | Investimento por ativo: R${investimento_por_ativo:.2f}")

def exibir_sinais_manual(dados_sinais, modelos_info=None):
    """
    Exibe a tabela de sinais consolidados com alinhamento visual corrigido,
    mesmo com uso de cores ANSI e emojis.
    """
    import re

    if modelos_info is None:
        modelos_info = {}

    # Se n√£o houver dados, n√£o exibe a tabela
    if not dados_sinais:
        print("\n\033[1;33m‚ö†Ô∏è Nenhum sinal dispon√≠vel para exibi√ß√£o\033[0m")
        return

    def largura_visual(texto):
        # Remove c√≥digos ANSI para calcular o comprimento real
        return len(re.sub(r'\x1b[^m]*m', '', texto))

    def ajustar_largura(texto, largura):
        visivel = largura_visual(texto)
        return texto + ' ' * max(0, largura - visivel)

    # Larguras fixas por coluna
    COL_ATIVO = 8
    COL_POSICAO = 10
    COL_INTERVALO = 8
    COL_INDICADORES = 25
    COL_SINAL = 10
    COL_REGIME = 12
    COL_RAZOES = 50

    print("\n\033[1;36müöÄ [SINAIS CONSOLIDADOS] üöÄ\033[0m")
    print("‚îå" + "‚îÄ" * COL_ATIVO + "‚î¨" + "‚îÄ" * COL_POSICAO + "‚î¨" + "‚îÄ" * COL_INTERVALO +
          "‚î¨" + "‚îÄ" * COL_INDICADORES + "‚î¨" + "‚îÄ" * COL_SINAL + "‚î¨" + "‚îÄ" * COL_REGIME +
          "‚î¨" + "‚îÄ" * COL_RAZOES + "‚îê")

    cabecalhos = ["ATIVO", "POSI√á√ÉO", "INTERV.", "INDICADORES", "SINAL", "REGIME", "RAZ√ïES"]
    larguras = [COL_ATIVO, COL_POSICAO, COL_INTERVALO, COL_INDICADORES, COL_SINAL, COL_REGIME, COL_RAZOES]

    linha_cabecalho = "‚îÇ" + "‚îÇ".join(
        [ajustar_largura(f"\033[1m{cab.center(w)}\033[0m", w) for cab, w in zip(cabecalhos, larguras)]
    ) + "‚îÇ"
    print(linha_cabecalho)

    print("‚îú" + "‚îÄ" * COL_ATIVO + "‚îº" + "‚îÄ" * COL_POSICAO + "‚îº" + "‚îÄ" * COL_INTERVALO +
          "‚îº" + "‚îÄ" * COL_INDICADORES + "‚îº" + "‚îÄ" * COL_SINAL + "‚îº" + "‚îÄ" * COL_REGIME +
          "‚îº" + "‚îÄ" * COL_RAZOES + "‚î§")

    # Verificar se temos dados para exibir
    if len(dados_sinais) == 0:
        linha_vazia = "‚îÇ" + " " * COL_ATIVO + "‚îÇ" + " " * COL_POSICAO + "‚îÇ" + " " * COL_INTERVALO + "‚îÇ" + \
                    " " * COL_INDICADORES + "‚îÇ" + " " * COL_SINAL + "‚îÇ" + " " * COL_REGIME + "‚îÇ" + \
                    " Nenhum sinal dispon√≠vel " + " " * (COL_RAZOES - 24) + "‚îÇ"
        print(linha_vazia)
    else:
        for item in dados_sinais:
            try:
                # Garantir 6 elementos em cada item
                if len(item) < 6:
                    item = list(item)
                    while len(item) < 6:
                        item.append("")
                
                ativo, posicao, indicadores_texto, sinal, regime, razoes = item[:6]
                
                # Garantir que todos os valores s√£o strings
                ativo = str(ativo) if ativo is not None else ""
                posicao = str(posicao) if posicao is not None else ""
                sinal = str(sinal) if sinal is not None else ""
                regime = str(regime) if regime is not None else ""
                razoes = str(razoes) if razoes is not None else ""
                
                # Obter informa√ß√µes do modelo
                intervalo = modelos_info.get(ativo, "N/A")
                
                # Processar indicadores
                if isinstance(indicadores_texto, list):
                    ind_texto = ", ".join(indicadores_texto[:3])
                    if len(indicadores_texto) > 3:
                        ind_texto += "..."
                else:
                    ind_texto = str(indicadores_texto)
                
                # Truncar textos longos
                ind_texto = ind_texto[:COL_INDICADORES-3] + "..." if len(ind_texto) > COL_INDICADORES else ind_texto
                razoes_formatada = razoes[:COL_RAZOES-3] + "..." if len(razoes) > COL_RAZOES else razoes
                
                # Cores
                ativo_c = f"\033[1;33m{ativo.center(COL_ATIVO)}\033[0m"
                posicao_c = f"\033[1;32m{posicao.center(COL_POSICAO)}\033[0m" if "SIM" in posicao else f"\033[1;31m{posicao.center(COL_POSICAO)}\033[0m"
                sinal_c = f"\033[1;32m{sinal.center(COL_SINAL)}\033[0m" if "COMPRA" in sinal else f"\033[1;31m{sinal.center(COL_SINAL)}\033[0m" if "VENDA" in sinal else f"\033[1;37m{sinal.center(COL_SINAL)}\033[0m"
                regime_c = f"\033[1;34m{regime.center(COL_REGIME)}\033[0m" if "TEND√äNCIA" in regime else f"\033[1;33m{regime.center(COL_REGIME)}\033[0m" if "LATERAL" in regime else f"\033[1;37m{regime.center(COL_REGIME)}\033[0m"
                
                linha = "‚îÇ" + "‚îÇ".join([
                    ajustar_largura(ativo_c, COL_ATIVO),
                    ajustar_largura(posicao_c, COL_POSICAO),
                    ajustar_largura(intervalo.center(COL_INTERVALO), COL_INTERVALO),
                    ajustar_largura(ind_texto, COL_INDICADORES),
                    ajustar_largura(sinal_c, COL_SINAL),
                    ajustar_largura(regime_c, COL_REGIME),
                    ajustar_largura(razoes_formatada, COL_RAZOES)
                ]) + "‚îÇ"
                
                print(linha)
                
            except Exception as e:
                print(f"‚îÇ Erro ao processar item: {str(e)[:COL_ATIVO + COL_POSICAO + COL_INTERVALO + COL_INDICADORES + COL_SINAL + COL_REGIME + COL_RAZOES - 25]} ‚îÇ")

    print("‚îî" + "‚îÄ" * COL_ATIVO + "‚î¥" + "‚îÄ" * COL_POSICAO + "‚î¥" + "‚îÄ" * COL_INTERVALO +
          "‚î¥" + "‚îÄ" * COL_INDICADORES + "‚î¥" + "‚îÄ" * COL_SINAL + "‚î¥" + "‚îÄ" * COL_REGIME +
          "‚î¥" + "‚îÄ" * COL_RAZOES + "‚îò")

    saldo_brl = saldos_disponiveis.get("BRL", 0)
    investimento_por_ativo = saldos_disponiveis.get("investimento_por_ativo", 0)
    print(f"\n\033[1;32müí∞ Saldo BRL: R${saldo_brl:.2f}\033[0m | \033[1;36mInvestimento por ativo: R${investimento_por_ativo:.2f}\033[0m")

def enviar_relatorio_diario(modo_forcado=False):
    """
    Envia os resumos de performance por per√≠odo.
    
    Par√¢metros:
    - modo_forcado: Se True, envia todos os relat√≥rios independente da programa√ß√£o hor√°ria
    
    Programa√ß√£o normal (quando modo_forcado=False):
    - Ano: 1x ao dia, √†s 08h
    - M√™s: 2x ao dia, √†s 08h e 20h
    - Semana: 4x ao dia (02h, 08h, 14h, 20h)
    - Di√°rio: a cada 1h
    """
    import traceback
    import sqlite3
    import os
    import time

    global historico_resumos_enviados, historico_saldos
    if 'historico_resumos_enviados' not in globals():
        historico_resumos_enviados = {"ano": None, "mes": None, "semana": None, "dia": None}
    
    if 'historico_saldos' not in globals():
        historico_saldos = {"ano": None, "mes": None, "semana": None, "dia": None}

    agora = datetime.now()
    hora = agora.hour

    # Determina quais relat√≥rios devem ser enviados
    if modo_forcado:
        # No modo for√ßado, envia todos os relat√≥rios
        print("üì§ Enviando todos os resumos for√ßados...")
        enviar_ano = enviar_mes = enviar_semana = enviar_dia = True
    else:
        # No modo normal, verifica o hor√°rio para cada relat√≥rio
        def pode_enviar(periodo, janelas_horas):
            ultima = historico_resumos_enviados.get(periodo)
            if hora in janelas_horas and (not ultima or ultima.date() != agora.date() or ultima.hour != hora):
                historico_resumos_enviados[periodo] = agora
                return True
            return False
        
        # Programa√ß√£o normal de envios
        enviar_ano = pode_enviar("ano", [8])
        enviar_mes = pode_enviar("mes", [8, 20])
        enviar_semana = pode_enviar("semana", [2, 8, 14, 20])
        enviar_dia = pode_enviar("dia", list(range(24)))  # Sempre que a hora mudar
        
        if not any([enviar_ano, enviar_mes, enviar_semana, enviar_dia]):
            return  # Nenhum envio neste momento

    # Obter dados atuais
    try:
        # Garantir que os saldos est√£o atualizados
        listar_saldos(modo_silencioso=True)
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao atualizar saldos: {e}")

    saldo_brl = saldos_disponiveis.get("BRL", 0)
    total_ativos = 0
    valor_ativos = 0
    
    try:
        for ativo in ativos:
            base = ativo.replace("BRL", "").replace("USDT", "")
            qtd = saldos_disponiveis.get(base, 0)
            try:
                preco = float(client.get_symbol_ticker(symbol=ativo)["price"])
                valor_ativos += qtd * preco
                total_ativos += 1
            except Exception as e:
                if modo_forcado:  # Log mais detalhado no modo for√ßado
                    print(f"‚ö†Ô∏è Erro ao obter pre√ßo para {ativo}: {e}")
                continue
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao calcular valor dos ativos: {e}")
        
    saldo_total = saldo_brl + valor_ativos
    
    if modo_forcado:
        print(f"üí∞ Saldo atual: BRL={saldo_brl:.2f}, Ativos={valor_ativos:.2f}, Total={saldo_total:.2f}")

    # Fun√ß√£o para buscar dados hist√≥ricos de opera√ß√µes do banco/arquivo
    
    def obter_saldo_historico(dias_atras, periodo):
        """
        Tenta obter um saldo hist√≥rico de X dias atr√°s, baseado em opera√ß√µes registradas.
        Retorna o saldo estimado do per√≠odo.
        """
        data_referencia = agora - timedelta(days=dias_atras)
        
        # M√©todo 1: Tentar buscar do banco de dados de opera√ß√µes
        if os.path.exists(DB_PATH):
            try:
                conn = sqlite3.connect(DB_PATH)
                cursor = conn.cursor()
                
                # Consulta para somar valores de opera√ß√µes at√© a data
                cursor.execute("""
                SELECT SUM(CASE WHEN operacao = 'COMPRA' THEN -valor_total ELSE valor_total END) 
                FROM operacoes 
                WHERE data > ?
                """, (data_referencia.strftime("%Y-%m-%d %H:%M:%S"),))
                
                resultado = cursor.fetchone()
                conn.close()
                
                if resultado and resultado[0] is not None:
                    # O saldo em BRL mudou por esse valor desde a data de refer√™ncia
                    variacao_desde_referencia = float(resultado[0])
                    # O saldo anterior seria o atual menos a varia√ß√£o
                    saldo_historico = saldo_total - variacao_desde_referencia
                    if modo_forcado:
                        print(f"üìä Dados hist√≥ricos (BD) para {periodo}: {saldo_historico:.2f}")
                    return saldo_historico
            except Exception as e:
                if modo_forcado:
                    print(f"‚ö†Ô∏è Erro ao buscar saldo hist√≥rico do banco: {e}")
        
        # M√©todo 2: Tentar buscar do arquivo CSV
        if os.path.exists(HISTORICO_ARQUIVO):
            try:
                import csv
                
                # Calcular o impacto total de opera√ß√µes ap√≥s a data de refer√™ncia
                variacao_desde_referencia = 0
                operacoes_encontradas = False
                
                with open(HISTORICO_ARQUIVO, 'r', newline='') as f:
                    reader = csv.reader(f)
                    next(reader)  # Pular cabe√ßalho
                    
                    for row in reader:
                        try:
                            data_op = datetime.strptime(row[0], "%Y-%m-%d %H:%M:%S")
                            if data_op > data_referencia:
                                valor_total = float(row[5])
                                operacao = row[2]
                                # COMPRA diminui saldo, VENDA aumenta
                                if operacao == "COMPRA":
                                    variacao_desde_referencia -= valor_total
                                else:
                                    variacao_desde_referencia += valor_total
                                operacoes_encontradas = True
                        except (ValueError, IndexError):
                            continue
                
                if operacoes_encontradas:
                    # O saldo anterior seria o atual menos a varia√ß√£o
                    saldo_historico = saldo_total - variacao_desde_referencia
                    if modo_forcado:
                        print(f"üìä Dados hist√≥ricos (CSV) para {periodo}: {saldo_historico:.2f}")
                    return saldo_historico
            except Exception as e:
                if modo_forcado:
                    print(f"‚ö†Ô∏è Erro ao buscar saldo hist√≥rico do CSV: {e}")
        
        # M√©todo 3: Usar hist√≥rico j√° registrado anteriormente
        if periodo in historico_saldos and historico_saldos[periodo] is not None:
            if modo_forcado:
                print(f"üìä Usando hist√≥rico salvo para {periodo}: {historico_saldos[periodo]:.2f}")
            return historico_saldos[periodo]
            
        # M√©todo 4: Usar saldo atual com desconto estimado (√∫ltimo recurso)
        saldo_estimado = None
        if dias_atras > 180:  # Ano
            saldo_estimado = saldo_total * 0.85  # Estima 15% menos que o atual
        elif dias_atras > 90:  # Semestre
            saldo_estimado = saldo_total * 0.92  # Estima 8% menos que o atual
        elif dias_atras > 30:  # M√™s
            saldo_estimado = saldo_total * 0.96  # Estima 4% menos que o atual
        elif dias_atras > 7:   # Semana 
            saldo_estimado = saldo_total * 0.98  # Estima 2% menos que o atual
        else:
            saldo_estimado = saldo_total * 0.99  # Estima 1% menos que o atual
            
        if modo_forcado:
            print(f"üìä Usando valor estimado para {periodo}: {saldo_estimado:.2f}")
            
        return saldo_estimado

    # Definir per√≠odos de busca para cada tipo de relat√≥rio
    dias_por_periodo = {
        "dia": 1,        # 1 dia atr√°s
        "semana": 7,     # 7 dias atr√°s
        "mes": 30,       # 30 dias atr√°s
        "ano": 365       # 365 dias atr√°s
    }

    # Enviar relat√≥rios com varia√ß√£o por per√≠odo
    periodos_para_enviar = [
        ("ano", enviar_ano), 
        ("mes", enviar_mes), 
        ("semana", enviar_semana), 
        ("dia", enviar_dia)
    ]
    
    for periodo, condicao_envio in periodos_para_enviar:
        if condicao_envio:
            try:
                # Busca saldo hist√≥rico com base no per√≠odo
                dias_atras = dias_por_periodo[periodo]
                #saldo_historico = obter_saldo_historico(dias_atras, periodo)
                # Gerar chave √∫nica por per√≠odo
                if periodo == "dia":
                    chave = agora.strftime("%Y-%m-%d")
                elif periodo == "semana":
                    chave = f"{agora.year}-W{agora.isocalendar()[1]}"
                elif periodo == "mes":
                    chave = agora.strftime("%Y-%m")
                elif periodo == "ano":
                    chave = str(agora.year)

                # Utiliza saldo inicial fixo por per√≠odo
                saldo_historico = obter_saldo_inicial_fixo(periodo, chave, saldo_total)

                
                if saldo_historico is None:
                    # Se n√£o encontrar hist√≥rico, usar o saldo atual (varia√ß√£o ser√° zero)
                    saldo_historico = saldo_total
                
                # Salvar como √∫ltimo valor conhecido para este per√≠odo
                historico_saldos[periodo] = saldo_total  # Atualiza para a pr√≥xima execu√ß√£o
                
                variacao_valor = saldo_total - saldo_historico
                variacao_pct = (variacao_valor / saldo_historico) * 100 if saldo_historico != 0 else 0
                emoji_var = "üü¢" if variacao_valor > 0 else "üî¥" if variacao_valor < 0 else "‚ö™"

                mensagem = f"üíπ *Resumo de Performance ({periodo.upper()})*\n"
                mensagem += f"üí∞ *Saldo Inicial:* R$ {saldo_historico:.2f}\n"
                mensagem += f"üí∞ *Saldo Total:* R$ {saldo_total:.2f}\n"
                mensagem += f"üìä *Saldo BRL:* R$ {saldo_brl:.2f}\n"
                mensagem += f"üìä *Saldo Ativos:* R$ {valor_ativos:.2f}\n"
                mensagem += f"{emoji_var} *Varia√ß√£o:* {variacao_valor:+.2f} BRL ({variacao_pct:+.2f}%)\n"
                mensagem += f"üïí *Hora:* {agora.strftime('%d/%m/%Y %H:%M')}"

                if modo_forcado:
                    print(f"Enviando resumo de {periodo}...")
                    # Adicionar delay para evitar flood de mensagens no modo for√ßado
                    time.sleep(1)
                
                enviar_mensagem_telegram(
                    f"\n\nüìÖ *Resumo {periodo.capitalize()}*\n{mensagem}",
                    nivel="importante", 
                    bypass_frequency=True
                )
                
                if modo_forcado:
                    print(f"‚úÖ Resumo de {periodo} enviado com sucesso!")
            
            except Exception as e:
                print(f"‚ùå Erro ao enviar resumo de {periodo}: {e}")
                if modo_forcado:
                    print(traceback.format_exc())

# Fun√ß√£o auxiliar para chamada for√ßada (apenas para compatibilidade)
def enviar_relatorio_diario_forcado():
    """
    Fun√ß√£o de compatibilidade que apenas chama enviar_relatorio_diario
    em modo for√ßado.
    """
    return enviar_relatorio_diario(modo_forcado=True)

def enviar_boletim_aprendizado():
    """
    Gera e envia um resumo semanal da evolu√ß√£o dos modelos.
    """
    mensagens = []
    for ativo in ativos:
        try:
            _, _, meta, indicadores, intervalo, _ = carregar_modelo(ativo)
            score = meta.get("score", 0)
            timestamp = meta.get("timestamp", "N/A")
            mensagens.append(f"üìà {ativo}: Score: {score:.2f} | Intervalo: {intervalo} | Atualizado em: {timestamp}")
        except:
            mensagens.append(f"‚ùå {ativo}: Modelo n√£o carregado.")

    mensagem = "*üß† Boletim Semanal de Modelos*\n\n" + "\n".join(mensagens)
    enviar_mensagem_telegram(mensagem, nivel="importante", bypass_frequency=True)


# === 08. Registro de opera√ß√µes === #
def salvar_logs_detalhados(max_ciclos=5):
    """
    Captura e salva os logs completos dos primeiros X ciclos de execu√ß√£o.
    Par√¢metros:
    - max_ciclos: N√∫mero m√°ximo de ciclos para salvar logs detalhados
    """
    import os
    import sys
    from io import StringIO
    
    # Criar pasta para logs detalhados se n√£o existir
    logs_dir = "logs_detalhados"
    os.makedirs(logs_dir, exist_ok=True)
    
    # Vari√°veis para controle do ciclo atual
    ciclo_atual = 0
    max_ciclos_ativos = max_ciclos
    log_buffer = None
    original_stdout = None
    arquivo_log_atual = None
    timestamp_inicio = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Fun√ß√£o para iniciar a captura de logs de um ciclo
    def iniciar_captura_ciclo():
        nonlocal log_buffer, original_stdout, arquivo_log_atual, ciclo_atual
        ciclo_atual += 1
        print(f" Iniciando captura detalhada do ciclo #{ciclo_atual}")
        
        # Nome do arquivo de log para este ciclo
        arquivo_log_atual = os.path.join(
            logs_dir,
            f"log_detalhado_IA_ciclo_{ciclo_atual}_{timestamp_inicio}.txt"
        )
        
        # Iniciar captura do stdout
        log_buffer = StringIO()
        original_stdout = sys.stdout
        sys.stdout = log_buffer
        
        # Cabe√ßalho do log
        print("="*80)
        print(f"LOG DETALHADO - CICLO {ciclo_atual} - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
        print("="*80)
        print(f"Configura√ß√£o de ambiente:")
        print(f"- Python: {sys.version}")
        print(f"- Diret√≥rio atual: {os.getcwd()}")
        print(f"- Timestamp de in√≠cio: {timestamp_inicio}")
        print("="*80)
    
    # Fun√ß√£o para finalizar a captura de logs do ciclo atual
    def finalizar_captura_ciclo():
        nonlocal log_buffer, original_stdout, arquivo_log_atual, ciclo_atual
        if log_buffer is not None and original_stdout is not None:
            # Restaurar stdout original
            sys.stdout = original_stdout
            
            # Rodap√© do log
            log_buffer.write("\n" + "="*80 + "\n")
            log_buffer.write(f"FIM DO LOG - CICLO {ciclo_atual} - {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            log_buffer.write("="*80 + "\n")
            
            # Salvar o buffer no arquivo
            with open(arquivo_log_atual, 'w', encoding='utf-8') as f:
                f.write(log_buffer.getvalue())
                
            print(f" Log detalhado do ciclo #{ciclo_atual} salvo em: {arquivo_log_atual}")
            
            # Limpar buffer
            log_buffer.close()
            log_buffer = None
        #else:
        #    print(f" Aviso: Tentativa de finalizar captura sem inicializa√ß√£o pr√©via")
    
    # Fun√ß√£o para verificar se devemos continuar capturando
    def deve_capturar():
        return ciclo_atual < max_ciclos_ativos
    
    # Retornar as fun√ß√µes de controle como um dicion√°rio
    return {
        'iniciar_captura': iniciar_captura_ciclo,
        'finalizar_captura': finalizar_captura_ciclo,
        'deve_capturar': deve_capturar,
        'ciclo_atual': lambda: ciclo_atual
    }    

def monitorar():
    """
    Loop principal que monitora os ativos, calcula indicadores,
    gera sinais e executa opera√ß√µes com tratamento de erros melhorado.
    Agora com envio autom√°tico de resumo hor√°rio ao Telegram.
    """

    # Verificar se a comunica√ß√£o com Telegram est√° funcionando
    print("Testando conex√£o com Telegram...")
    try:
        #enviar_mensagem_telegram("üîÑ Teste de comunica√ß√£o com Telegram", nivel="alerta")
        print("‚úÖ Comunica√ß√£o com Telegram OK")
    except Exception as e:
        print(f"‚ùå Erro na comunica√ß√£o com Telegram: {e}")
        import traceback
        print(traceback.format_exc())

    # Informe de in√≠cio do c√≥digo
    enviar_mensagem_telegram("üöÄ Sistema de monitoramento iniciado com sucesso", nivel="importante", bypass_frequency=True)

    import time
    import pandas as pd
    import numpy as np

    # ‚úÖ Corrige poss√≠vel erro: criar pasta para o log principal
    os.makedirs("logs_execucao", exist_ok=True)

    # ‚úÖ Redefine handler para salvar apenas em arquivo, sem log no console
    logger = logging.getLogger("trading")
    logger.setLevel(logging.INFO)

    file_handler = logging.FileHandler("logs_execucao/execucao_IA.txt", encoding='utf-8')
    file_handler.setFormatter(logging.Formatter("%(asctime)s - %(message)s"))
    logger.handlers = [file_handler]  # Apenas em arquivo

    # Logger de exce√ß√µes
    loggers = configurar_logging()
    log_exception = loggers['log_exception']

    captura_logs = salvar_logs_detalhados(max_ciclos=5)

    try:
        ATIVOS = ["BTCBRL", "ETHBRL", "DOGEBRL", "SOLBRL", "XRPBRL"]

        if 'falar' in globals():
            falar("Sistema de trading iniciado")

        inicializar_bd()
        inicializar_historico()

        global ultima_atualizacao_modelo_por_ativo, modelos_info, ultimo_relatorio
        if 'ultima_atualizacao_modelo_por_ativo' not in globals():
            ultima_atualizacao_modelo_por_ativo = {}

        listar_saldos(modo_silencioso=True)
        ultimo_relatorio = datetime.now()

        try:
            enviar_relatorio_diario_forcado()
        except Exception as e:
            log_exception(e, "Erro ao enviar relat√≥rio di√°rio no in√≠cio")

        modelos_info = {}
        tempo_minimo_entre_operacoes = {}

        for ativo in ATIVOS:
            try:
                _, _, _, _, intervalo, _ = carregar_modelo(ativo)
                tempo_minimo_entre_operacoes[ativo] = calcular_tempo_espera(intervalo)
            except Exception as e:
                log_exception(e, f"Erro ao inicializar tempo m√≠nimo para {ativo}")
                tempo_minimo_entre_operacoes[ativo] = 30 * 60

        ciclo = 0
        while True:
            ciclo += 1
            agora = datetime.now()

            # ‚úÖ Divis√≥ria de in√≠cio de ciclo no console
            print("\n" + "="*80)
            print(f"üöÄ INICIANDO CICLO {ciclo} √†s {agora.strftime('%d/%m/%Y %H:%M:%S')}")
            print("="*80 + "\n")

            if captura_logs['deve_capturar']():
                captura_logs['iniciar_captura']()

            inicio_ciclo = datetime.now()
            logger.info(f"Iniciando ciclo {ciclo} de monitoramento √†s {inicio_ciclo.strftime('%H:%M:%S')}")

            try:
                # ‚úÖ Resumo a cada hora
                agora = datetime.now()
                if ultimo_relatorio is None or (agora - ultimo_relatorio).total_seconds() >= 3600:
                    enviar_relatorio_diario()
                    ultimo_relatorio = agora
                    logger.info("üì§ Resumo hor√°rio enviado ao Telegram.")

                # Enviar boletim semanal aos domingos √†s 09:00
                if agora.weekday() == 6 and agora.hour == 9:
                    enviar_boletim_aprendizado()
                    
            except Exception as e:
                log_exception(e, "Erro ao enviar relat√≥rio peri√≥dico")

            try:
                dados_mercado, novos_modelos_info = buscar_dados_binance(ATIVOS, modo_silencioso=True)

                # Verifica√ß√£o de atualiza√ß√µes e exibi√ß√£o compacta
                modelos_carregados_linha = []
                for ativo in ATIVOS:
                    novo_intervalo = novos_modelos_info.get(ativo, "N/A")
                    intervalo_anterior = modelos_info.get(ativo)

                    # Verifica se houve altera√ß√£o do intervalo
                    houve_atualizacao = intervalo_anterior and intervalo_anterior != novo_intervalo
                    simbolo = "üåü" if houve_atualizacao else "‚úÖ"

                    modelos_carregados_linha.append(f"{simbolo} {ativo} ({novo_intervalo})")

                # Atualiza os modelos_info com os novos
                modelos_info.update(novos_modelos_info)

                # Exibe em linha
                linha_formatada = " | ".join(modelos_carregados_linha)
                print(f"\nüß† Modelos carregados: {linha_formatada}\n")

                if not dados_mercado:
                    logger.warning("Nenhum dado de mercado recebido. Pulando ciclo.")
                    time.sleep(60)
                    if captura_logs['ciclo_atual']() <= 5:
                        captura_logs['finalizar_captura']()
                    continue

                dados_sinais = []
                for ativo in ATIVOS:
                    try:
                        df = dados_mercado.get(ativo)
                        if df is None or df.empty:
                            print(f"‚ö†Ô∏è Dados vazios para {ativo}, pulando...")
                            continue

                        # Verificar se as colunas necess√°rias existem
                        if not all(col in df.columns for col in ['close', 'high', 'low', 'volume']):
                            print(f"‚ö†Ô∏è Colunas necess√°rias ausentes para {ativo}")
                            continue

                        # Importante: Garantir que o DataFrame tem as colunas necess√°rias para o c√°lculo dos indicadores
                        df_proc = df.copy()
                        
                        # Calcular indicadores t√©cnicos
                        #print(f"üî¢ Calculando indicadores para {ativo}...")
                        df_proc = calcular_indicadores(df_proc, ativo, silencioso=False)  # Defina como False para ver os logs
                        
                        # Calcular regime de mercado
                        df_proc = calcular_regime_mercado(df_proc)
                        
                        # Sanitizar o DataFrame para remover poss√≠veis valores problem√°ticos
                        df_proc = sanitizar_dataframe(df_proc)
                        
                        registrar_distribuicao_features(ativo, df_proc)

                        # Verificar se os indicadores foram calculados
                        if 'EMA_9' not in df_proc.columns or 'RSI' not in df_proc.columns:
                            print(f"‚ö†Ô∏è Indicadores n√£o foram calculados para {ativo}. Colunas: {df_proc.columns.tolist()}")
                            continue
                        
                        #print(f"üìä Gerando sinal para {ativo} com indicadores...")
                        sinal, regime, razoes = gerar_sinal_consolidado(df_proc, ativo)
                        posicao = "‚úÖ SIM" if (posicoes_ativas.get(ativo, False)) else "üõë N√ÉO"
                        _, _, _, indicadores, _, _ = carregar_modelo(ativo)
                        
                        dados_sinais.append([ativo, posicao, indicadores, sinal, regime, razoes])
                        #print(f"‚úÖ Sinal gerado para {ativo}: {sinal}, regime: {regime}")
                        
                    except Exception as e:
                        log_exception(e, f"Erro ao processar {ativo}")
                        print(f"‚ùå Erro ao processar {ativo}: {str(e)}")

                # Exibir os sinais na tabela
                exibir_sinais_manual(dados_sinais, modelos_info)
                executar_ordens(dados_sinais)
                
                # üîÑ Aprendizado retroativo com base no hist√≥rico
                for ativo in ATIVOS:
                    try:
                        retroalimentar_com_csv(ativo)
                    except Exception as e:
                        log_exception(e, f"Erro na retroalimenta√ß√£o do modelo {ativo}")

            except Exception as e:
                log_exception(e, "Erro no ciclo principal de monitoramento")
                print(f"‚ùå Erro no ciclo principal: {str(e)}")

            fim_ciclo = datetime.now()
            duracao_ciclo = (fim_ciclo - inicio_ciclo).total_seconds()
            tempo_espera = max(60 - duracao_ciclo, 5)

            logger.info(f"Ciclo {ciclo} conclu√≠do em {duracao_ciclo:.1f}s. Aguardando {tempo_espera:.0f}s...")

            if captura_logs['ciclo_atual']() <= 5:
                captura_logs['finalizar_captura']()

            time.sleep(tempo_espera)

    except KeyboardInterrupt:
        if captura_logs['ciclo_atual']() <= 5:
            captura_logs['finalizar_captura']()
        logger.info("Interrup√ß√£o manual do sistema.")
        enviar_mensagem_telegram("‚ö†Ô∏è Sistema interrompido manualmente.", nivel="alerta", bypass_frequency=True)

    except Exception as e:
        if captura_logs['ciclo_atual']() <= 5:
            captura_logs['finalizar_captura']()
        log_exception(e, "Erro cr√≠tico no sistema")
        enviar_mensagem_telegram(f"üö® Sistema parado por erro cr√≠tico: {str(e)[:100]}...", nivel="alerta", bypass_frequency=True)
        print("\n ESTADO DOS MODELOS AO FINAL DO CICLO:")
        exibir_modelos_vigentes(f"CICLO {ciclo} - FINAL")
        logger.error("Tentando reiniciar em 5 minutos...")
        time.sleep(300)
        monitorar()

if __name__ == "__main__":
    # Inicializa banco de dados e hist√≥rico
    inicializar_bd()
    inicializar_historico()
    
    # Inicia monitoramento
    monitorar()


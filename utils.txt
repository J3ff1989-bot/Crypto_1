# === 00. IMPORTS === #
import requests

# === 01. Fun√ß√µes auxiliares de DataFrame === #
def sanitizar_dataframe(df):
    """
    Fun√ß√£o aprimorada para limpar o DataFrame de valores problem√°ticos.
    - Remove valores NaN
    - Substitui infinitos por valores m√°ximos
    - Normaliza colunas com valores extremos
    
    Par√¢metros:
        df (pandas.DataFrame): DataFrame a ser limpo
        
    Retorna:
        pandas.DataFrame: DataFrame limpo
    """
    import pandas as pd
    import numpy as np
    
    # Criar c√≥pia para n√£o modificar o original
    df_limpo = df.copy()
    
    # Converter tudo para num√©rico (exceto timestamp)
    for col in df_limpo.columns:
        if col != 'timestamp':
            df_limpo[col] = pd.to_numeric(df_limpo[col], errors='coerce')
    
    # Detectar colunas com valores infinitos
    colunas_com_infinitos = []
    for col in df_limpo.columns:
        if col != 'timestamp' and np.isinf(df_limpo[col]).any():
            colunas_com_infinitos.append(col)
            # Substituir infinitos por valores grandes mas finitos
            max_finito = np.nanmax(df_limpo[col][~np.isinf(df_limpo[col])])
            min_finito = np.nanmin(df_limpo[col][~np.isinf(df_limpo[col])])
            
            # Substituir +inf pelo m√°ximo finito * 1.5
            mascara_pos_inf = np.isinf(df_limpo[col]) & (df_limpo[col] > 0)
            if mascara_pos_inf.any():
                df_limpo.loc[mascara_pos_inf, col] = max_finito * 1.5 if max_finito > 0 else 1e6
            
            # Substituir -inf pelo m√≠nimo finito * 1.5
            mascara_neg_inf = np.isinf(df_limpo[col]) & (df_limpo[col] < 0)
            if mascara_neg_inf.any():
                df_limpo.loc[mascara_neg_inf, col] = min_finito * 1.5 if min_finito < 0 else -1e6
    
    # Normalizar colunas com valores extremos
    for col in df_limpo.columns:
        if col != 'timestamp':
            # Verificar se h√° valores extremos
            q1 = df_limpo[col].quantile(0.25)
            q3 = df_limpo[col].quantile(0.75)
            iqr = q3 - q1
            
            # Limite para valores extremos
            limite_superior = q3 + 3 * iqr
            limite_inferior = q1 - 3 * iqr
            
            # Se h√° valores extremos, normalizar
            extremos_superiores = (df_limpo[col] > limite_superior)
            extremos_inferiores = (df_limpo[col] < limite_inferior)
            
            if extremos_superiores.sum() > 0 or extremos_inferiores.sum() > 0:
                # Substituir extremos por limites
                df_limpo.loc[extremos_superiores, col] = limite_superior
                df_limpo.loc[extremos_inferiores, col] = limite_inferior
    
    # Remover NaNs
    df_limpo = df_limpo.fillna(method='ffill').fillna(method='bfill').fillna(0)
    
    if colunas_com_infinitos:
        print(f"‚ö†Ô∏è Substitu√≠dos valores infinitos nas colunas: {', '.join(colunas_com_infinitos)}")
    
    return df_limpo

def calcular_indicadores(df, ativo, silencioso=True):
    """
    Calcula indicadores t√©cnicos para um DataFrame de dados de pre√ßo.
    
    Args:
        df: DataFrame com dados OHLCV
        ativo: Nome do ativo para log
        silencioso: Se True, suprime logs
    
    Returns:
        DataFrame com indicadores adicionados
    """
    from ta.trend import EMAIndicator, MACD
    from ta.momentum import RSIIndicator
    from ta.volume import OnBalanceVolumeIndicator, VolumeWeightedAveragePrice
    from ta.volatility import AverageTrueRange
    from ta.trend import ADXIndicator
    import pandas as pd
    import numpy as np
    
    # === C√ìDIGO DE VALIDA√á√ÉO INTEGRADO (substitui a chamada para validar_dados_binance) ===
    if df is None or df.empty:
        if not silencioso:
            print(f"‚ùå Dados vazios ou nulos para {ativo}")
        return pd.DataFrame(columns=["timestamp", "open", "high", "low", "close", "volume"])
    
    # Verificar colunas essenciais
    colunas_essenciais = ["open", "high", "low", "close", "volume"]
    colunas_faltando = [col for col in colunas_essenciais if col not in df.columns]

    if colunas_faltando and not silencioso:
        print(f"‚ö†Ô∏è {ativo}: Colunas ausentes: {colunas_faltando}. Criando valores padr√£o...")
    
    # Adicionar colunas ausentes com valores padr√£o
    for col in colunas_faltando:
        df[col] = df["close"] if "close" in df.columns and col != "close" else 0.0
    
    # Converter tipos de dados
    for col in colunas_essenciais:
        df[col] = pd.to_numeric(df[col], errors='coerce')
    
    # Garantir que timestamp seja datetime
    if "timestamp" in df.columns and not pd.api.types.is_datetime64_any_dtype(df["timestamp"]):
        df["timestamp"] = pd.to_datetime(df["timestamp"])
    
    # Ordenar por timestamp
    if "timestamp" in df.columns:
        df = df.sort_values("timestamp")
    
    # Remover duplicatas no timestamp se existir
    if "timestamp" in df.columns:
        df = df.drop_duplicates(subset=["timestamp"])
    
    # Remover linhas com NaN nas colunas essenciais
    df = df.dropna(subset=colunas_essenciais)
    
    # Resetar √≠ndice
    df = df.reset_index(drop=True)
    
    if len(df) < 26 and not silencioso:
        print(f"‚ö†Ô∏è {ativo}: Apenas {len(df)} candles dispon√≠veis. Indicadores podem ser imprecisos.")
    # === FIM DO C√ìDIGO DE VALIDA√á√ÉO INTEGRADO ===
    
    if df is None or df.empty or len(df) < 2:
        return df
    
    try:
        # Calcular indicadores b√°sicos
        df["EMA_9"] = EMAIndicator(close=df["close"], window=9).ema_indicator().fillna(0)
        df["EMA_21"] = EMAIndicator(close=df["close"], window=21).ema_indicator().fillna(0)
        df["RSI"] = RSIIndicator(close=df["close"], window=14).rsi().fillna(0)
        df["OBV"] = OnBalanceVolumeIndicator(close=df["close"], volume=df["volume"]).on_balance_volume().fillna(0)

        macd_calc = MACD(close=df["close"], window_slow=26, window_fast=12, window_sign=9)
        df["MACD"] = macd_calc.macd().fillna(0)

        vwap_calc = VolumeWeightedAveragePrice(
            high=df["high"],
            low=df["low"],
            close=df["close"],
            volume=df["volume"],
            window=14
        )
        df["VWAP"] = vwap_calc.volume_weighted_average_price().fillna(0)
        
        # Adicionar indicadores adicionais (ATR e ADX)
        df["ATR"] = AverageTrueRange(
            high=df["high"],
            low=df["low"],
            close=df["close"],
            window=14
        ).average_true_range().fillna(0)
        
        adx_indicator = ADXIndicator(
            high=df["high"],
            low=df["low"],
            close=df["close"],
            window=14
        )
        df["ADX"] = adx_indicator.adx().fillna(0)

    except Exception as e:
        if not silencioso:
            print(f"‚ùå ERRO ao calcular indicadores para {ativo}: {e}")
            import traceback
            print(traceback.format_exc())
    
    return df


# === 02. Fun√ß√µes de regime/mercado e Telegram === # 
def calcular_regime_mercado(df):
    """
    Determina o regime de mercado (TEND√äNCIA, LATERAL, ALTA_VOL, NEUTRO)
    baseado em indicadores t√©cnicos, com tratamento de dados melhorado.
    
    Par√¢metros:
        df (pandas.DataFrame): DataFrame com dados de mercado
    
    Retorna:
        pandas.DataFrame: DataFrame original com coluna "Regime" adicionada
    """
    import numpy as np
    import pandas as pd
    
    # Valida√ß√£o de entrada
    if df is None or df.empty:
        print("‚ùå DataFrame vazio em calcular_regime_mercado")
        df_out = pd.DataFrame()
        df_out["Regime"] = ["DESCONHECIDO"]
        return df_out
    
    # Criar c√≥pia para evitar modificar o original
    df_out = df.copy()
    
    # Verificar colunas necess√°rias
    colunas_necessarias = ["high", "low", "close"]
    colunas_ausentes = [col for col in colunas_necessarias if col not in df_out.columns]
    
    if colunas_ausentes:
        print(f"‚ö†Ô∏è Colunas necess√°rias ausentes: {colunas_ausentes}")
        # Usar fallback se houver coluna 'close'
        if 'close' in df_out.columns:
            for col in colunas_ausentes:
                df_out[col] = df_out['close']
        else:
            # Sem dados suficientes para calcular regime
            df_out["Regime"] = "DESCONHECIDO"
            return df_out
    
    # Verificar se h√° entradas suficientes
    if len(df_out) < 15:
        print(f"‚ö†Ô∏è Dados insuficientes para calcular regime: {len(df_out)} candles")
        df_out["Regime"] = "LATERAL"  # Regime padr√£o com poucos dados
        return df_out
    
    # C√°lculo de ADX (Average Directional Index)
    if "ADX" not in df_out.columns:
        try:
            from ta.trend import ADXIndicator
            adx_indicator = ADXIndicator(
                high=df_out["high"],
                low=df_out["low"],
                close=df_out["close"],
                window=14,
                fillna=True
            )
            df_out["ADX"] = adx_indicator.adx()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao calcular ADX: {e}")
            df_out["ADX"] = 15  # Valor padr√£o (regime LATERAL)
    
    # C√°lculo de ATR (Average True Range)
    if "ATR" not in df_out.columns:
        try:
            from ta.volatility import AverageTrueRange
            atr_indicator = AverageTrueRange(
                high=df_out["high"],
                low=df_out["low"],
                close=df_out["close"],
                window=14,
                fillna=True
            )
            df_out["ATR"] = atr_indicator.average_true_range()
        except Exception as e:
            print(f"‚ö†Ô∏è Erro ao calcular ATR: {e}")
            df_out["ATR"] = 0  # Valor padr√£o (sem volatilidade)
    
    # Garantir que colunas ADX e ATR est√£o como n√∫meros
    df_out["ADX"] = pd.to_numeric(df_out["ADX"], errors="coerce").fillna(15)
    df_out["ATR"] = pd.to_numeric(df_out["ATR"], errors="coerce").fillna(0)
    
    # Calcular m√©dia m√≥vel do ATR
    df_out["ATR_MA"] = df_out["ATR"].rolling(window=14, min_periods=1).mean()
    
    # Determinar regime com base nos indicadores
    # 1. Primeiro determinar se √© TEND√äNCIA ou LATERAL pelo ADX
    df_out["Regime_ADX"] = np.where(
        df_out["ADX"] > 30, "TEND√äNCIA",
        np.where(df_out["ADX"] > 20, "NEUTRO", "LATERAL")
    )
    
    # 2. Considerar volatilidade (ATR) para refinar o regime
    # Volatilidade alta sobrep√µe o regime, exceto se ADX for muito alto
    df_out["Regime"] = np.where(
        (df_out["ATR"] > df_out["ATR_MA"] * 1.3) & (df_out["ADX"] <= 35), "ALTA_VOL",
        df_out["Regime_ADX"]
    )
    
    # 3. Adicionar regra para evitar mudan√ßas bruscas de regime
    # (suaviza√ß√£o para prevenir sinal de falso)
    if len(df_out) > 5:
        # Contar ocorr√™ncias de cada regime nas √∫ltimas 5 barras
        ultimos_regimes = df_out["Regime"].iloc[-5:].value_counts()
        regime_mais_comum = ultimos_regimes.idxmax() if not ultimos_regimes.empty else "LATERAL"
        regime_atual = df_out["Regime"].iloc[-1]
        
        # Se o regime atual aparece apenas uma vez nas √∫ltimas 5 barras, 
        # e √© diferente do anterior, manter o anterior (suaviza√ß√£o)
        if ultimos_regimes.get(regime_atual, 0) <= 1 and regime_atual != df_out["Regime"].iloc[-2]:
            df_out.loc[df_out.index[-1], "Regime"] = regime_mais_comum
    
    # Remover colunas auxiliares
    df_out = df_out.drop(columns=["Regime_ADX", "ATR_MA"], errors="ignore")
    
    return df_out

def enviar_mensagem_telegram(mensagem, nivel="info", consolidar=False, bypass_frequency=False):
    """
    Envia mensagem para o Telegram com controle de frequ√™ncia e prioridade.
    
    Par√¢metros:
    - mensagem: Texto da mensagem
    - nivel: "debug", "info", "importante", "alerta", "sinal"
    - consolidar: Se True, adiciona ao buffer e envia depois
    - bypass_frequency: Se True, ignora intervalo m√≠nimo entre mensagens
    """
    import requests
    import traceback
    from datetime import datetime, timedelta

    # üîß Configura√ß√µes diretas (sem getenv)
    TELEGRAM_BOT_TOKEN = '7812777606:AAG3uUTG6_aaV2Rjzx-Zaop69OWk7uiedik'
    TELEGRAM_CHAT_ID = '-1002281646681'

    # Inicializar vari√°veis globais
    global ultima_mensagem_telegram, buffer_mensagens, contador_nivel

    if 'ultima_mensagem_telegram' not in globals():
        ultima_mensagem_telegram = {}
        buffer_mensagens = {"modelos": [], "sistema": [], "sinais": []}
        contador_nivel = {
            "debug": 0, "info": 0, "importante": 0,
            "alerta": 0, "sinal": 0
        }

    # ‚ûï Se consolidar, apenas adiciona ao buffer
    if consolidar:
        categoria = "sistema"
        if "Modelo" in mensagem:
            categoria = "modelos"
        elif "Sinal" in mensagem:
            categoria = "sinais"
        buffer_mensagens[categoria].append({
            "texto": mensagem,
            "nivel": nivel,
            "timestamp": datetime.now()
        })
        return

    # ‚è±Ô∏è Controle de frequ√™ncia por n√≠vel
    agora = datetime.now()
    intervalos_minimos = {
        "debug": timedelta(hours=12),
        "info": timedelta(hours=4),
        "importante": timedelta(hours=2),
        "alerta": timedelta(minutes=30),
        "sinal": timedelta(minutes=10)
    }

    if not bypass_frequency and nivel in ultima_mensagem_telegram:
        tempo_desde_ultima = agora - ultima_mensagem_telegram[nivel]
        if tempo_desde_ultima < intervalos_minimos[nivel]:
            contador_nivel[nivel] += 1
            return

    # Prefixos para clareza no Telegram
    prefixos = {
        "debug": "üîç DEBUG",
        "info": "‚ÑπÔ∏è INFO",
        "importante": "üîî IMPORTANTE",
        "alerta": "‚ö†Ô∏è ALERTA",
        "sinal": "üö® SINAL DE TRADING"
    }

    # Montar mensagem final
    texto_final = f"{prefixos.get(nivel, '')}\n{mensagem}"
    if contador_nivel[nivel] > 0:
        texto_final += f"\n\n_+{contador_nivel[nivel]} mensagens similares ignoradas_"
        contador_nivel[nivel] = 0

    # Envio real com tratamento robusto
    try:
        url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
        data = {
            "chat_id": TELEGRAM_CHAT_ID,
            "text": texto_final,
            "parse_mode": "Markdown"
        }
        response = requests.post(url, data=data)
        response.raise_for_status()
        json_resp = response.json()

        if not json_resp.get("ok"):
            print("‚ùå Telegram retornou erro:", json_resp)
        else:
            print(f"‚úÖ Mensagem enviada com sucesso. N√≠vel: {nivel}")
            ultima_mensagem_telegram[nivel] = agora

    except Exception as e:
        print(f"‚ùå [TELEGRAM] Erro ao enviar mensagem: {e}")
        print(traceback.format_exc())

def enviar_resumo_consolidado():
    """Envia um resumo consolidado de todas as mensagens no buffer"""
    # Verificar se h√° mensagens para enviar
    total_mensagens = sum(len(msgs) for msgs in buffer_mensagens.values())
    if total_mensagens == 0:
        return
    
    mensagem = "*Resumo Consolidado do Sistema*\n\n"
    
    # Processar mensagens sobre modelos
    if buffer_mensagens["modelos"]:
        mensagem += "üìä *Atualiza√ß√µes de Modelos:*\n"
        total_atualizados = len(buffer_mensagens["modelos"])
        mensagem += f"- {total_atualizados} modelos atualizados\n"
        # Incluir detalhes dos 3 mais recentes
        for msg in buffer_mensagens["modelos"][-3:]:
            # Extrair apenas a primeira linha para resumo
            primeira_linha = msg["texto"].split("\n")[0]
            mensagem += f"- {primeira_linha}\n"
        if total_atualizados > 3:
            mensagem += f"- _+{total_atualizados-3} outras atualiza√ß√µes_\n"
    
    # Processar sinais de trading
    if buffer_mensagens["sinais"]:
        mensagem += "\nüìà *Sinais de Trading:*\n"
        for msg in buffer_mensagens["sinais"]:
            # Extrair informa√ß√µes essenciais para sinais
            linhas = msg["texto"].split("\n")
            if len(linhas) > 2:
                mensagem += f"- {linhas[1]} - {linhas[2]}\n"
            else:
                mensagem += f"- {msg['texto']}\n"
    
    # Processar mensagens do sistema
    if buffer_mensagens["sistema"]:
        mensagem += "\n‚öôÔ∏è *Informa√ß√µes do Sistema:*\n"
        # Agrupar por tipo de informa√ß√£o
        num_otimizacoes = sum(1 for msg in buffer_mensagens["sistema"] if "otimiza" in msg["texto"].lower())
        num_backtests = sum(1 for msg in buffer_mensagens["sistema"] if "backtest" in msg["texto"].lower())
        
        if num_otimizacoes > 0:
            mensagem += f"- {num_otimizacoes} opera√ß√µes de otimiza√ß√£o\n"
        if num_backtests > 0:
            mensagem += f"- {num_backtests} backtests realizados\n"
    
    # Limpar o buffer ap√≥s envio
    for categoria in buffer_mensagens:
        buffer_mensagens[categoria] = []
    
    # Enviar a mensagem consolidada
    enviar_mensagem_telegram(mensagem, nivel="importante")


# === 03. Fun√ß√µes de notifica√ß√£o e m√©tricas === # 
def criar_metrica_composta(lucro, win_rate, max_drawdown, trades):
    """
    Cria uma m√©trica composta que equilibra retorno, risco e consist√™ncia
    
    Args:
        lucro: Lucro total da simula√ß√£o
        win_rate: Taxa de acertos (0-1)
        max_drawdown: Drawdown m√°ximo durante a simula√ß√£o (%)
        trades: N√∫mero total de trades
    
    Returns:
        float: Pontua√ß√£o composta (mais alta = melhor)
    """
    # Converter para valores normalizados
    lucro_norm = min(1.0, max(0, lucro / 200.0))  # Normalizar para 200 de lucro m√°ximo
    wr_norm = win_rate  # J√° est√° entre 0-1
    
    # Penalizar drawdown severo (menor = melhor)
    if max_drawdown <= 0:
        dd_norm = 1.0  # Sem drawdown √© √≥timo
    else:
        dd_norm = max(0, 1.0 - (max_drawdown / 50.0))  # 50% de drawdown = 0 pontos
    
    # B√¥nus para n√∫mero suficiente de trades (confiabilidade estat√≠stica)
    if trades < 5:
        trade_factor = 0.5  # Penalizar modelos com poucos trades
    elif trades < 10:
        trade_factor = 0.8  # Aceit√°vel mas n√£o ideal
    else:
        trade_factor = 1.0  # Bom n√∫mero de trades
    
    # C√°lculo da m√©trica composta
    # 40% peso para lucro, 25% para win rate, 25% para drawdown, 10% para n√∫mero de trades
    metrica = (0.4 * lucro_norm + 0.25 * wr_norm + 0.25 * dd_norm) * trade_factor
    
    return metrica

def notificar_modelo_carregado(ativo, intervalo, taxa_acerto, indicadores):
    """
    Envia uma notifica√ß√£o ao Telegram quando um novo modelo √© carregado.
    """
    try:
        # Se tiver mais de 3 indicadores, exibe apenas os 3 primeiros por brevidade
        indicadores_resumo = indicadores[:3]
        if len(indicadores) > 3:
            indicadores_resumo = indicadores_resumo + ["..."]
        
        mensagem = f"""
üìä *Modelo Carregado*
- Ativo: {ativo}
- Intervalo: {intervalo}
- Precis√£o: {taxa_acerto:.2f}%
- Indicadores: {', '.join(indicadores_resumo if indicadores_resumo else ['N/A'])}
"""
        enviar_mensagem_telegram(mensagem, nivel="info")
    except Exception as e:
        print(f"‚ö†Ô∏è Erro ao notificar carregamento de modelo: {e}")
    
# === 04. Fun√ß√µes de execu√ß√£o compartilhadas === #
def executar_pipeline_modelo(modelo, scaler, X, indicadores_esperados, min_confianca=0.55):
    """
    Executa o pipeline do modelo treinado com consist√™ncia com o backtest.
    - Garante ordem, presen√ßa e formato das colunas esperadas.
    - Aplica o scaler (se dispon√≠vel).
    - Retorna previs√£o (compra/venda) e probabilidade.

    Par√¢metros:
        modelo: Modelo treinado carregado
        scaler: Scaler usado no backtest (ou None)
        X: DataFrame com features
        indicadores_esperados: Lista de colunas esperadas pelo modelo
        min_confianca: float entre 0-1. Previs√µes abaixo disso retornam 'NEUTRO'

    Retorna:
        tuple: (sinal, confianca)
            sinal: "üü¢ COMPRA", "üî¥ VENDA" ou "‚ö™ NEUTRO"
            confianca: probabilidade da classe prevista (float)
    """
    import numpy as np
    import pandas as pd

    if X is None or X.empty:
        return "‚ö™ NEUTRO", 0.0

    # 1. Garantir ordem e presen√ßa das colunas
    X_proc = X.copy()
    for col in indicadores_esperados:
        if col not in X_proc.columns:
            X_proc[col] = 0.0
    X_proc = X_proc[indicadores_esperados]

    # 2. Sanitizar
    X_proc = X_proc.replace([np.inf, -np.inf], 0).fillna(0)

    # 3. Aplicar scaler se dispon√≠vel
    if scaler and hasattr(scaler, "transform"):
        try:
            X_proc = scaler.transform(X_proc)
        except Exception as e:
            print(f"[ERRO] Falha ao aplicar scaler: {e}")
            return "‚ö™ NEUTRO", 0.0
    else:
        X_proc = X_proc.values

    # 4. Prever com o modelo
    try:
        previsao = modelo.predict(X_proc)[0]
        confianca = 0.5
        if hasattr(modelo, "predict_proba"):
            proba = modelo.predict_proba(X_proc)[0]
            confianca = proba[int(previsao)]
    except Exception as e:
        print(f"[ERRO] Falha ao prever com o modelo: {e}")
        return "‚ö™ NEUTRO", 0.0

    # 5. Aplicar pol√≠tica de confian√ßa
    if confianca < min_confianca:
        return "‚ö™ NEUTRO", confianca

    if previsao == 1:
        return "üü¢ COMPRA", confianca
    elif previsao == 0:
        return "üî¥ VENDA", confianca
    else:
        return "‚ö™ NEUTRO", confianca
